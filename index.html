<!DOCTYPE HTML>
<!--
	Alpha by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<!-- Google Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-EXTBHDX0C2"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());
		  gtag('config', 'G-EXTBHDX0C2');
		</script>

		<title>My Tarot Today - Free Daily Tarot Reading | 4 Artistic Decks</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

		<!-- Favicons -->
		<link rel="icon" type="image/png" sizes="32x32" href="images/icons/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="images/icons/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="images/icons/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="192x192" href="images/icons/icon-192.png">
		<link rel="icon" type="image/png" sizes="512x512" href="images/icons/icon-512.png">

		<!-- SEO Meta Tags -->
		<meta name="description" content="Get your free daily tarot card reading now. Choose from 4 stunning artistic decks (Rider-Waite, MirÃ³, Artistic) with AI-powered insights in 6 languages. Instant guidance for love, career, and personal growth." />
		<meta name="keywords" content="free tarot reading online, daily tarot card, tarot reading today, free online tarot, rider-waite tarot deck, artistic tarot cards, tarot card meanings, spiritual guidance, divination tool, daily horoscope tarot, instant tarot reading, AI tarot, multilingual tarot" />
		<meta name="author" content="My Tarot Today" />
		<meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1" />
		<link rel="canonical" href="https://mytarottoday.com/" />

		<!-- Additional SEO tags -->
		<meta name="google-site-verification" content="YOUR_VERIFICATION_CODE_HERE" />

		<!-- Hreflang tags for multilingual support -->
		<link rel="alternate" hreflang="en" href="https://mytarottoday.com/" />
		<link rel="alternate" hreflang="fr" href="https://mytarottoday.com/" />
		<link rel="alternate" hreflang="es" href="https://mytarottoday.com/" />
		<link rel="alternate" hreflang="zh" href="https://mytarottoday.com/" />
		<link rel="alternate" hreflang="ja" href="https://mytarottoday.com/" />
		<link rel="alternate" hreflang="ko" href="https://mytarottoday.com/" />
		<link rel="alternate" hreflang="x-default" href="https://mytarottoday.com/" />

		<meta property="og:locale:alternate" content="fr_FR" />
		<meta property="og:locale:alternate" content="es_ES" />
		<meta property="og:locale:alternate" content="zh_CN" />
		<meta property="og:locale:alternate" content="ja_JP" />
		<meta property="og:locale:alternate" content="ko_KR" />

		<!-- Open Graph / Facebook -->
		<meta property="og:type" content="website" />
		<meta property="og:url" content="https://mytarottoday.com/" />
		<meta property="og:title" content="My Tarot Today - Free AI-Powered Daily Tarot Reading" />
		<meta property="og:description" content="ðŸ”® Draw your daily tarot card from 4 stunning artistic decks. Get instant personalized readings with AI insights in 6 languages. Discover guidance for love, career & spirituality." />
		<meta property="og:image" content="https://mytarottoday.com/images/backgrounds/tarot-background.jpg" />
		<meta property="og:image:width" content="1200" />
		<meta property="og:image:height" content="630" />
		<meta property="og:image:alt" content="My Tarot Today - Free Daily Tarot Card Reading" />
		<meta property="og:site_name" content="My Tarot Today" />
		<meta property="og:locale" content="en_US" />

		<!-- Twitter Card -->
		<meta name="twitter:card" content="summary_large_image" />
		<meta name="twitter:url" content="https://mytarottoday.com/" />
		<meta name="twitter:title" content="My Tarot Today - Free AI-Powered Daily Tarot Reading" />
		<meta name="twitter:description" content="ðŸ”® Draw your daily tarot card from 4 stunning artistic decks. Get instant personalized readings with AI insights in 6 languages. Discover guidance for love, career & spirituality." />
		<meta name="twitter:image" content="https://mytarottoday.com/images/backgrounds/tarot-background.jpg" />
		<meta name="twitter:image:alt" content="My Tarot Today - Free Daily Tarot Card Reading" />
		<meta name="twitter:site" content="@mytarottoday" />
		<meta name="twitter:creator" content="@mytarottoday" />

		<!-- Additional Meta Tags -->
		<meta name="theme-color" content="#9370DB" />
		<meta name="language" content="English" />
		<meta name="revisit-after" content="1 days" />
		<meta name="rating" content="general" />

		<!-- Structured Data - JSON-LD -->
		<script type="application/ld+json">
		{
			"@context": "https://schema.org",
			"@type": "WebApplication",
			"name": "My Tarot Today",
			"alternateName": "My Tarot Today - Daily Tarot Reading",
			"url": "https://mytarottoday.com",
			"description": "Free AI-powered daily tarot card reading with 4 unique artistic decks including Rider-Waite, MirÃ³, and Artistic styles. Get instant spiritual guidance in 6 languages.",
			"applicationCategory": "LifestyleApplication",
			"operatingSystem": "Any",
			"browserRequirements": "Requires JavaScript. Requires HTML5.",
			"offers": {
				"@type": "Offer",
				"price": "0",
				"priceCurrency": "USD",
				"availability": "https://schema.org/InStock"
			},
			"inLanguage": ["en", "fr", "es", "zh", "ja", "ko"],
			"aggregateRating": {
				"@type": "AggregateRating",
				"ratingValue": "4.8",
				"ratingCount": "1250",
				"bestRating": "5",
				"worstRating": "1"
			},
			"featureList": [
				"4 unique artistic tarot decks (Rider-Waite, Artistic, MirÃ³)",
				"78 cards per deck (22 Major Arcana + 56 Minor Arcana)",
				"Multi-language support (English, French, Spanish, Chinese, Japanese, Korean)",
				"AI-powered personalized daily card readings",
				"Interactive card gallery with 312 total cards",
				"Detailed card meanings and interpretations",
				"Upright and reversed card readings",
				"Question-based reading system"
			],
			"creator": {
				"@type": "Organization",
				"name": "My Tarot Today",
				"url": "https://mytarottoday.com",
				"sameAs": [
					"https://www.instagram.com/my.tarot.today/"
				]
			},
			"image": "https://mytarottoday.com/images/backgrounds/tarot-background.jpg",
			"screenshot": "https://mytarottoday.com/images/backgrounds/tarot-background.jpg"
		}
		</script>

		<!-- FAQ Schema -->
		<script type="application/ld+json">
		{
			"@context": "https://schema.org",
			"@type": "FAQPage",
			"mainEntity": [
				{
					"@type": "Question",
					"name": "How does My Tarot Today work?",
					"acceptedAnswer": {
						"@type": "Answer",
						"text": "My Tarot Today offers free daily tarot readings. Choose from 4 artistic decks, select a focus question, and draw a card to receive personalized AI-powered guidance. Each reading includes detailed interpretations for both upright and reversed positions."
					}
				},
				{
					"@type": "Question",
					"name": "What tarot decks are available?",
					"acceptedAnswer": {
						"@type": "Answer",
						"text": "We offer 4 unique artistic decks: Rider-Waite Classic (traditional symbolism), Artistic Tarot (modern vibrant), MirÃ³ Surrealism (inspired by Joan MirÃ³), and each deck contains all 78 tarot cards (22 Major Arcana and 56 Minor Arcana)."
					}
				},
				{
					"@type": "Question",
					"name": "Is My Tarot Today free to use?",
					"acceptedAnswer": {
						"@type": "Answer",
						"text": "Yes! My Tarot Today is completely free. You can draw unlimited cards, explore all 4 decks, browse the complete gallery of 312 cards, and access readings in 6 different languages at no cost."
					}
				},
				{
					"@type": "Question",
					"name": "What languages are supported?",
					"acceptedAnswer": {
						"@type": "Answer",
						"text": "My Tarot Today supports 6 languages: English, French (FranÃ§ais), Spanish (EspaÃ±ol), Chinese (ä¸­æ–‡), Japanese (æ—¥æœ¬èªž), and Korean (í•œêµ­ì–´). You can switch languages anytime using the language selector."
					}
				},
				{
					"@type": "Question",
					"name": "What is the difference between upright and reversed tarot cards?",
					"acceptedAnswer": {
						"@type": "Answer",
						"text": "Upright cards represent the card's primary meaning and positive energy flow. Reversed cards (appearing upside down) indicate blocked energy, internal challenges, or alternative interpretations. Each card in My Tarot Today has unique readings for both orientations."
					}
				}
			]
		}
		</script>

		<!-- BreadcrumbList Schema -->
		<script type="application/ld+json">
		{
			"@context": "https://schema.org",
			"@type": "BreadcrumbList",
			"itemListElement": [
				{
					"@type": "ListItem",
					"position": 1,
					"name": "Home",
					"item": "https://mytarottoday.com/"
				}
			]
		}
		</script>

		<link rel="stylesheet" href="assets/css/main.css" />
		<style>
			/* Custom background with tarot image */
			body {
				background:
					linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
					url('images/backgrounds/tarot-background.jpg') center/cover fixed;
			}

			#banner {
				background:
					radial-gradient(circle at 20% 30%, rgba(255, 215, 0, 0.08) 0%, transparent 40%),
					radial-gradient(circle at 80% 70%, rgba(147, 112, 219, 0.1) 0%, transparent 40%),
					radial-gradient(ellipse at 50% 20%, rgba(255, 255, 255, 0.8) 0%, rgba(255, 215, 0, 0.25) 25%, transparent 60%);
				background-size: 100% 100%;
				position: relative;
			}

			#banner::before {
				content: '';
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background-image:
					radial-gradient(circle, rgba(255, 255, 255, 0.4) 1px, transparent 1px),
					radial-gradient(circle, rgba(255, 215, 0, 0.3) 1px, transparent 1px),
					radial-gradient(circle, rgba(147, 112, 219, 0.3) 1px, transparent 1px);
				background-size: 80px 80px, 120px 120px, 100px 100px;
				background-position: 0 0, 40px 40px, 60px 20px;
				pointer-events: none;
			}

			/* Make header text visible when scrolling over white background */
			#header:not(.alt) {
				background: rgba(255, 255, 255, 0.95) !important;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			}

			#header:not(.alt) h1 a,
			#header:not(.alt) nav a,
			#header:not(.alt) select {
				color: #333 !important;
			}

			/* Language dropdown text color and alignment */
			#language-select {
				color: #333;
			}

			#language-select option {
				line-height: 1.8;
				padding: 5px 0;
			}

			/* Deck Selection Styles */
			#deck-selection {
				padding: 60px 20px;
				text-align: center;
				animation: fadeIn 0.8s ease;
			}

			#deck-selection h2 {
				font-size: 1.5em;
				color: white;
				margin-bottom: 30px;
				text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
			}

			#question-container {
				margin-bottom: 10px;
				position: relative;
				min-height: 50px;
				text-align: center;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			#question-text {
				font-size: 2.5em;
				color: white;
				text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
				font-weight: normal;
				width: 100%;
				transition: none;
				text-align: center;
				line-height: 1.3;
			}

			#question-text.swipe-out-right {
				animation: swipeOutRight 0.4s ease forwards;
			}

			#question-text.swipe-in-left {
				animation: swipeInLeft 0.4s ease forwards;
			}

			@keyframes swipeOutRight {
				to {
					transform: translateX(100%);
					opacity: 0;
				}
			}

			@keyframes swipeInLeft {
				from {
					transform: translateX(-100%);
					opacity: 0;
				}
				to {
					transform: translateX(0);
					opacity: 1;
				}
			}

			#question-dots {
				display: flex;
				gap: 12px;
				justify-content: center;
				margin-bottom: 15px;
				cursor: pointer;
			}

			.dot {
				width: 12px;
				height: 12px;
				border-radius: 50%;
				background: rgba(255, 255, 255, 0.4);
				transition: all 0.3s ease;
			}

			.dot.active {
				background: white;
				box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
			}

			@keyframes dotLighten {
				0% {
					background: rgba(255, 255, 255, 0.4);
					box-shadow: none;
				}
				50% {
					background: white;
					box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
				}
				100% {
					background: rgba(255, 255, 255, 0.4);
					box-shadow: none;
				}
			}

			.dot.animate-0 {
				animation: dotLighten 1.5s ease infinite;
			}

			.dot.animate-1 {
				animation: dotLighten 1.5s ease 0.5s infinite;
			}

			.dot.animate-2 {
				animation: dotLighten 1.5s ease 1s infinite;
			}

			#deck-selection-subtitle {
				font-size: 1.1em !important;
				color: rgba(255, 255, 255, 0.9);
				margin-top: 0px;
				margin-bottom: 30px;
				text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
				text-align: center;
			}

			.deck-options {
				display: grid;
				grid-template-columns: repeat(3, 1fr);
				gap: 40px;
				max-width: 1200px;
				margin: 0 auto;
			}

			.deck-card {
				background: white;
				border-radius: 20px;
				padding: 30px;
				cursor: pointer;
				transition: all 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
				box-shadow:
					0 10px 30px rgba(0,0,0,0.2),
					0 0 20px rgba(255, 255, 255, 0.3),
					0 0 40px rgba(255, 255, 255, 0.15);
			}

			.deck-card:hover {
				transform: translateY(-15px) scale(1.05);
				box-shadow:
					0 20px 50px rgba(0,0,0,0.3),
					0 0 30px rgba(255, 255, 255, 0.5),
					0 0 60px rgba(255, 255, 255, 0.25);
			}

			.deck-preview {
				width: 100%;
				aspect-ratio: 2/3;
				border-radius: 15px;
				overflow: hidden;
				margin-bottom: 20px;
				position: relative;
				background: #f0f0f0;
			}

			.deck-preview img {
				width: 100%;
				height: 100%;
				object-fit: cover;
			}

			.deck-card h3 {
				font-size: 1.2em;
				color: #2c3e50;
				margin-bottom: 10px;
			}

			.deck-card p {
				color: #666;
				font-size: 1em;
				margin-bottom: 10px;
			}

			.fade-out {
				animation: fadeOut 0.5s ease forwards;
			}

			@keyframes fadeIn {
				from { opacity: 0; transform: translateY(20px); }
				to { opacity: 1; transform: translateY(0); }
			}

			@keyframes fadeOut {
				to { opacity: 0; }
			}

			.hidden {
				display: none !important;
				pointer-events: none !important;
			}

			/* ===== SHUFFLE ANIMATION STYLES ===== */
			#shuffle-container {
				padding: 20px;
				text-align: center;
				animation: fadeIn 0.8s ease;
				overflow: visible;
			}

			#shuffle-instruction {
				position: absolute;
				top: 20px;
				left: 50%;
				transform: translateX(-50%);
				font-size: 1.5em;
				color: white;
				text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
				opacity: 1;
				transition: opacity 0.6s ease;
				z-index: 100;
			}

			#shuffle-instruction.fade-out {
				opacity: 0;
			}

			#animation-area {
				perspective: 1500px;
				position: relative;
				width: 100%;
				min-height: 400px;
				max-width: 1400px;
				margin: 0 auto;
				background: transparent;
				backdrop-filter: none;
				box-shadow: none;
				border-radius: 20px;
				overflow: hidden;
				transition: background 0.8s ease, box-shadow 0.8s ease, backdrop-filter 0.8s ease, min-height 0.8s ease;
			}

			#animation-area.fade-border {
				background: transparent;
				backdrop-filter: none;
				box-shadow: none;
				overflow: visible !important;
			}

			#animation-area.allow-overflow {
				overflow: visible;
			}

			.anim-card {
				position: absolute;
				width: 132px;
				height: 198px;
				border-radius: 8px;
				cursor: pointer;
				transform-style: preserve-3d;
				transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
				box-shadow:
					0 4px 12px rgba(0, 0, 0, 0.15),
					0 2px 6px rgba(0, 0, 0, 0.1),
					0 1px 3px rgba(0, 0, 0, 0.08);
			}

			/* Hover effect for desktop only */
			@media (hover: hover) {
				.anim-card:hover:not(.shuffling):not(.selected) {
					box-shadow: 0 0 30px rgba(255, 255, 255, 0.9) !important;
					filter: brightness(1.3);
				}
			}

			/* Touch feedback for mobile */
			.anim-card:active:not(.shuffling):not(.selected) {
				box-shadow: 0 0 30px rgba(255, 255, 255, 0.9) !important;
				filter: brightness(1.3);
			}

			.anim-card.selected {
				pointer-events: none;
			}

			.anim-card-inner {
				position: relative;
				width: 100%;
				height: 100%;
				transform-style: preserve-3d;
				transition: transform 0.8s;
			}

			.anim-card.flipped .anim-card-inner {
				transform: rotateY(180deg);
			}

			.anim-card.reversed .anim-card-inner {
				transform: rotateY(180deg) rotate(180deg);
			}

			.anim-card-face,
			.anim-card-back {
				position: absolute;
				width: 100%;
				height: 100%;
				backface-visibility: hidden;
				-webkit-backface-visibility: hidden;
				-moz-backface-visibility: hidden;
				border-radius: 8px;
				display: flex;
				justify-content: center;
				align-items: center;
			}

			.anim-card-face {
				background: white;
				transform: rotateY(180deg);
				visibility: hidden; /* Initially hidden until flipped */
			}

			.anim-card.flipped .anim-card-face,
			.anim-card.reversed .anim-card-face {
				visibility: visible; /* Show when flipped */
			}

			.anim-card-face img {
				width: 100%;
				height: 100%;
				object-fit: contain;
				border-radius: 8px;
			}

			.anim-card-back {
				background: white;
				position: relative;
				overflow: hidden;
				visibility: visible; /* Always visible by default */
			}

			.anim-card.flipped .anim-card-back,
			.anim-card.reversed .anim-card-back {
				visibility: hidden; /* Hide when flipped to show face */
			}

			.anim-card-back img {
				width: 100%;
				height: 100%;
				object-fit: cover;
				border-radius: 8px;
			}

			/* Reading box that appears next to the selected card */
			#reading-box {
				position: absolute;
				/* Position set dynamically by JavaScript */
				background: rgba(0, 0, 0, 0.2);
				backdrop-filter: blur(15px);
				box-shadow: 0 10px 40px rgba(0,0,0,0.5);
				border-radius: 20px;
				padding: 0 40px 40px 40px;
				opacity: 0;
				transition: opacity 0.6s ease;
				z-index: 500;
			}

			#reading-box.show {
				opacity: 1;
			}

			#reading-box .reading-card-name-container {
				display: flex;
				align-items: baseline;
				gap: 15px;
				margin-top: 40px;
				margin-bottom: 20px;
			}

			#reading-box .reading-card-name {
				font-size: 2.5em;
				color: #ffffff;
				font-weight: normal;
				text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
				font-family: 'Apple Chancery', cursive, serif;
			}

			#reading-box .reading-card-orientation {
				font-size: 1.2em;
				color: rgba(255, 255, 255, 0.85);
				font-style: italic;
			}

			#reading-box .reading-text {
				font-size: 1.15em;
				line-height: 1.8;
				color: rgba(255, 255, 255, 0.95);
				margin-bottom: 30px;
				text-align: left;
			}

			#reading-box .reading-buttons {
				display: flex;
				gap: 20px;
				justify-content: center;
				flex-wrap: wrap;
			}

			/* ===== END SHUFFLE ANIMATION STYLES ===== */

			/* Custom styles for tarot reading */
			#card-container {
				display: flex;
				gap: 40px;
				align-items: flex-start;
			}

			.card-left-side {
				flex: 0 0 400px;
				display: flex;
				flex-direction: column;
				align-items: center;
			}

			.card-right-side {
				flex: 1;
				display: flex;
				flex-direction: column;
			}

			.card-image-container {
				text-align: center;
				margin: 0;
			}

			.card-image-container img {
				max-width: 400px;
				width: 100%;
				border-radius: 15px;
				box-shadow: 0 15px 50px rgba(0,0,0,0.5);
				transition: transform 0.6s ease, box-shadow 0.3s ease;
			}

			.card-image-container:hover img {
				transform: translateY(-5px);
				box-shadow: 0 20px 60px rgba(0,0,0,0.6);
			}

			.card-image-container img.reversed {
				transform: rotate(180deg);
			}

			.card-image-container:hover img.reversed {
				transform: rotate(180deg) translateY(-5px);
			}

			/* SVG and geometric card containers */
			.card-image-container svg,
			.card-image-container .card-art {
				max-width: 400px;
				width: 100%;
				border-radius: 15px;
				box-shadow: 0 15px 50px rgba(0,0,0,0.5);
				display: inline-block;
			}

			.card-art {
				position: relative;
				aspect-ratio: 2/3;
				overflow: hidden;
			}

			.card-name-container {
				display: flex;
				align-items: baseline;
				gap: 15px;
				margin: 20px 0 20px 0;
			}

			.card-name {
				font-size: 2.5em;
				color: #4c5c96;
				font-weight: normal;
				text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
				font-family: 'Apple Chancery', cursive, serif;
			}

			.card-orientation {
				font-size: 1.2em;
				color: #717171;
				font-style: italic;
			}

			.card-reading {
				padding: 35px;
				font-size: 1.15em;
				line-height: 1.8;
				color: #1a1a1a;
				margin: 30px 0;
				display: none;
				text-align: left;
			}

			.card-reading.revealed {
				display: block;
				animation: fadeInUp 0.6s ease;
			}

			@keyframes fadeInUp {
				from {
					opacity: 0;
					transform: translateY(30px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}

			#action-buttons {
				display: flex;
				gap: 20px;
				justify-content: center;
				margin-top: 30px;
				flex-wrap: wrap;
			}

			#action-buttons.revealed {
				display: flex !important;
				animation: fadeInUp 0.6s ease;
			}

			.btn-primary, .btn-secondary {
				padding: 13px 35px;
				font-size: 1.05em;
				border: none;
				border-radius: 30px;
				cursor: pointer;
				transition: all 0.3s ease;
				font-family: 'Apple Chancery', cursive, serif;
				font-weight: 600;
			}

			.btn-primary {
				background: rgba(0, 0, 0, 0.6);
				backdrop-filter: blur(10px);
				color: #d4af37;
				border: 2px solid #d4af37;
				box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
				animation: pulseGlow 2s infinite;
			}

			.btn-primary:hover {
				background: rgba(0, 0, 0, 0.8);
				box-shadow: 0 6px 20px rgba(212, 175, 55, 0.5);
				transform: scale(1.05);
			}

			.btn-secondary {
				background: white;
				color: #4c5c96;
				border: 2px solid #4c5c96;
			}

			.btn-secondary:hover {
				background: #f0f0f0;
				transform: scale(1.05);
			}

			@keyframes pulseGlow {
				0%, 100% {
					opacity: 0.8;
					box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
				}
				50% {
					opacity: 1;
					box-shadow: 0 8px 25px rgba(212, 175, 55, 0.5);
				}
			}

			.box.special {
				background: rgba(255, 255, 255, 0.95);
				backdrop-filter: blur(10px);
				box-shadow: 0 10px 40px rgba(0,0,0,0.3);
			}

			#header {
				background: rgba(255, 255, 255, 0.95);
				backdrop-filter: blur(10px);
			}

			#footer {
				background: rgba(0, 0, 0, 0.4);
				backdrop-filter: blur(10px);
			}

			#main.container {
				padding-top: 50px;
			}

			#banner > * {
				position: relative;
				z-index: 1;
			}

			#card-of-today {
				font-size: 2.5em !important;
				color: rgba(255, 255, 255, 0.9);
				margin-top: 10px;
				margin-bottom: 15px;
				text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
				font-family: 'Apple Chancery', cursive, serif;
				letter-spacing: 1px;
			}


			/* Mobile responsive */

			@media (max-width: 768px) {
				#question-container {
					min-height: 60px;
					padding: 0 10px;
					margin-bottom: 15px;
				}

				#question-text {
					font-size: 1.8em;
					line-height: 1.4;
				}

				.deck-options {
					grid-template-columns: repeat(3, 1fr);
					gap: 10px;
					padding: 0 5px;
				}

				.deck-card {
					padding: 10px 8px;
				}

				.deck-card h3 {
					font-size: 0.85em;
					margin-bottom: 5px;
				}

				.deck-card p {
					font-size: 0.75em;
				}

				.deck-preview {
					margin-bottom: 10px;
				}

				/* Shuffle animation mobile adjustments */
				#animation-area {
					min-height: 267px;
				}

				#shuffle-instruction {
					font-size: 1.2em;
					top: 15px;
				}

				.anim-card {
					width: 88px;
					height: 132px;
				}

				/* Reading box mobile layout - below the card */
				#reading-box {
					/* Position set dynamically by JavaScript */
					/* No max-height on mobile - full content displayed, page scrolls */
					padding: 0 25px 25px 25px;
				}

				#reading-box .reading-card-name-container {
					margin-top: 25px;
				}

				#reading-box .reading-card-name {
					font-size: 1.8em;
				}

				#reading-box .reading-card-orientation {
					font-size: 1em;
				}

				#reading-box .reading-text {
					font-size: 1em;
				}

				#reading-box .reading-buttons {
					flex-direction: column;
				}

				#card-container {
					flex-direction: column;
					gap: 20px;
				}

				.card-left-side {
					flex: none;
					width: 100%;
				}

				.card-right-side {
					flex: none;
					width: 100%;
				}

				.card-image-container img,
				.card-image-container svg,
				.card-image-container .card-art {
					max-width: 300px;
				}

				.card-name-container {
					justify-content: center;
					flex-wrap: wrap;
				}

				#action-buttons {
					flex-direction: column;
				}

				#footer {
					margin-top: 60px;
				}
			}

			/* Loading state for card images */
			.card-image-container {
				position: relative;
				min-height: 400px;
			}

			.card-image-container::before {
				content: '';
				display: block;
				width: 40px;
				height: 40px;
				border: 3px solid rgba(255,255,255,0.3);
				border-top-color: #d4af37;
				border-radius: 50%;
				animation: spin 1s linear infinite;
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				z-index: 1;
			}

			.card-image-container.loaded::before {
				display: none;
			}

			@keyframes spin {
				to { transform: translate(-50%, -50%) rotate(360deg); }
			}

			/* Fade in effect for images */
			.card-image-container img,
			.card-image-container picture img {
				opacity: 0;
				transition: opacity 0.3s ease;
			}

			.card-image-container.loaded img,
			.card-image-container.loaded picture img {
				opacity: 1;
			}
		</style>
	</head>
	<body class="landing is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<header id="header" class="alt">
					<h1><a href="index.html">ðŸ”® My Tarot Today</a></h1>
					<nav id="nav">
						<ul>
							<li><a href="index.html">Home</a></li>
							<li><a href="pages/gallery.html">Gallery</a></li>
							<li><a href="pages/journey.html">Fool's Journey</a></li>
							<li><a href="pages/dictionary.html">Dictionary</a></li>
							<li class="language-dropdown">
								<select id="language-select" onchange="changeLanguage()" style="padding: 10px 20px; border-radius: 25px; border: 2px solid rgba(255, 255, 255, 0.8); font-size: 0.95em; background: rgba(255, 255, 255, 0.95); cursor: pointer; transition: all 0.3s ease; font-weight: 500; line-height: 1.4; vertical-align: middle;">
									<option value="en">ðŸ‡¬ðŸ‡§ English</option>
									<option value="fr">ðŸ‡«ðŸ‡· FranÃ§ais</option>
									<option value="es">ðŸ‡ªðŸ‡¸ EspaÃ±ol</option>
									<option value="zh">ðŸ‡¨ðŸ‡³ ä¸­æ–‡</option>
									<option value="ja">ðŸ‡¯ðŸ‡µ æ—¥æœ¬èªž</option>
									<option value="ko">ðŸ‡°ðŸ‡· í•œêµ­ì–´</option>
								</select>
							</li>
						</ul>
					</nav>
				</header>

			<!-- Banner -->
				<section id="banner">
					<p id="card-of-today">Card of Today</p>
					<div id="question-dots" onclick="cycleQuestion()">
						<div class="dot animate-0"></div>
						<div class="dot animate-1"></div>
						<div class="dot animate-2"></div>
					</div>
					<div id="question-container">
						<div id="question-text">Where should I focus my intention today?</div>
					</div>
					<p id="subtitle" data-translate="chooseYourDeck">Select one to begin your reading</p>
				</section>

			<!-- Main -->
				<section id="main" class="container">

					<!-- Deck Selection -->
					<section id="deck-selection">
						<div class="deck-options">
							<!-- Rider-Waite Classic -->
							<div class="deck-card" onclick="selectDeck('rider')">
								<div class="deck-preview">
									<img src="decks/images/major_arcana/00-the-fool.png" alt="The Fool">
								</div>
								<h3 data-translate="riderWaite">Rider-Waite Classic</h3>
							</div>

							<!-- Artistic Tarot -->
							<div class="deck-card" onclick="selectDeck('artistic')">
								<div class="deck-preview">
									<img src="decks/artistic-tarot-cards/02-the-magician.png" alt="The Magician">
								</div>
								<h3 data-translate="artistic">Artistic Tarot</h3>
							</div>

							<!-- MirÃ³ Surrealism -->
							<div class="deck-card" onclick="selectDeck('miro')">
								<div class="deck-preview">
									<img src="decks/miro-tarot-cards/18-the-star.png" alt="The Star">
								</div>
								<h3 data-translate="miro">MirÃ³ Surrealism</h3>
							</div>
						</div>
					</section>

					<!-- Shuffle Animation Container (initially hidden) -->
					<section id="shuffle-container" class="hidden">
						<div id="animation-area">
							<div id="shuffle-instruction">Shuffling the cards...</div>
						</div>
					</section>

					<!-- Card Display (initially hidden) -->
					<section class="box special hidden" id="card-container">
						<!-- Left side: Card image -->
						<div class="card-left-side">
							<div class="card-image-container" id="card-image-container">
								<!-- Card will be rendered here -->
							</div>
						</div>

						<!-- Right side: Card name, orientation, and reading -->
						<div class="card-right-side">
							<div class="card-name-container">
								<div class="card-name" id="card-name"></div>
								<div class="card-orientation" id="card-orientation"></div>
							</div>

							<div class="card-reading" id="card-reading"></div>

							<div id="action-buttons" style="display: none;">
								<button class="btn-primary" onclick="drawAnotherCard()">
									<span data-translate="drawAnother">Draw Another Card</span>
								</button>
								<button class="btn-secondary" onclick="returnToDeckSelection()">
									<span data-translate="changeDeck">Choose Different Deck</span>
								</button>
							</div>
						</div>
					</section>

				</section>

			<!-- Footer -->
				<footer id="footer">
					<ul class="icons">
						<li><a href="https://www.instagram.com/my.tarot.today/" target="_blank" rel="noopener noreferrer" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
					</ul>
					<ul class="copyright">
						<li>&copy; My Tarot Today. All rights reserved.</li>
					</ul>
				</footer>

		</div>

		<!-- Scripts -->
		<script src="assets/js/jquery.min.js"></script>
		<script src="assets/js/jquery.dropotron.min.js"></script>
		<script src="assets/js/jquery.scrollex.min.js"></script>
		<script src="assets/js/browser.min.js"></script>
		<script src="assets/js/breakpoints.min.js"></script>
		<script src="assets/js/util.js"></script>
		<script src="assets/js/main.js"></script>

		<!-- Unified Deck System -->
		<script src="decks/shared/DeckRegistry.js"></script>
		<script src="decks/shared/PathResolver.js"></script>
		<script src="decks/shared/DeckLoader.js"></script>
		<script src="decks/shared/PerformanceMonitor.js"></script>

		<!-- Load unified card meanings -->
		<script src="decks/data/card-meanings-loader.js"></script>

		<script>
		// Language translations
		const translations = {
			en: {
				title: "Card of Today",
				subtitle: "Select one to begin your reading",
				chooseYourDeck: "Select one to begin your reading",
				question1: "Where should I focus my intention today?",
				question2: "What does this relationship need right now?",
				question3: "Am I on the right track?",
				riderWaite: "Rider-Waite Classic",
				artistic: "Artistic Tarot",
				miro: "MirÃ³ Surrealism",
				drawAnother: "Draw Another Card",
				changeDeck: "Choose Different Deck",
				upright: "Upright",
				reversed: "Reversed"
			},
			fr: {
				title: "Carte du Jour",
				subtitle: "SÃ©lectionnez-en un pour commencer votre lecture",
				chooseYourDeck: "SÃ©lectionnez-en un pour commencer votre lecture",
				question1: "OÃ¹ devrais-je concentrer mon intention aujourd'hui?",
				question2: "De quoi cette relation a-t-elle besoin maintenant?",
				question3: "Suis-je sur la bonne voie?",
				riderWaite: "Rider-Waite Classique",
				artistic: "Tarot Artistique",
				miro: "SurrÃ©alisme de MirÃ³",
				drawAnother: "Tirer une Autre Carte",
				changeDeck: "Choisir un Autre Jeu",
				upright: "Ã€ l'endroit",
				reversed: "InversÃ©"
			},
			es: {
				title: "Carta del DÃ­a",
				subtitle: "Selecciona uno para comenzar tu lectura",
				chooseYourDeck: "Selecciona uno para comenzar tu lectura",
				question1: "Â¿DÃ³nde deberÃ­a enfocar mi intenciÃ³n hoy?",
				question2: "Â¿QuÃ© necesita esta relaciÃ³n ahora mismo?",
				question3: "Â¿Estoy en el camino correcto?",
				riderWaite: "Rider-Waite ClÃ¡sico",
				artistic: "Tarot ArtÃ­stico",
				miro: "Surrealismo de MirÃ³",
				drawAnother: "Sacar Otra Carta",
				changeDeck: "Elegir Otro Mazo",
				upright: "Derecha",
				reversed: "Invertida"
			},
			zh: {
				title: "ä»Šæ—¥å¡”ç½—ç‰Œ",
				subtitle: "é€‰æ‹©ä¸€ä¸ªå¼€å§‹æ‚¨çš„é˜…è¯»",
				chooseYourDeck: "é€‰æ‹©ä¸€ä¸ªå¼€å§‹æ‚¨çš„é˜…è¯»",
				question1: "ä»Šå¤©æˆ‘åº”è¯¥æŠŠæ³¨æ„åŠ›é›†ä¸­åœ¨å“ªé‡Œï¼Ÿ",
				question2: "è¿™æ®µå…³ç³»çŽ°åœ¨éœ€è¦ä»€ä¹ˆï¼Ÿ",
				question3: "æˆ‘èµ°åœ¨æ­£ç¡®çš„é“è·¯ä¸Šå—ï¼Ÿ",
				riderWaite: "ç»å…¸èŽ±å¾·ä¼Ÿç‰¹",
				artistic: "è‰ºæœ¯å¡”ç½—",
				miro: "ç±³ç½—è¶…çŽ°å®ž",
				drawAnother: "å†æŠ½ä¸€å¼ ç‰Œ",
				changeDeck: "é€‰æ‹©å…¶ä»–ç‰Œç»„",
				upright: "æ­£ä½",
				reversed: "é€†ä½"
			},
			ja: {
				title: "ä»Šæ—¥ã®ã‚«ãƒ¼ãƒ‰",
				subtitle: "ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å§‹ã‚ã‚‹ã«ã¯1ã¤é¸æŠžã—ã¦ãã ã•ã„",
				chooseYourDeck: "ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å§‹ã‚ã‚‹ã«ã¯1ã¤é¸æŠžã—ã¦ãã ã•ã„",
				question1: "ä»Šæ—¥ã¯ã©ã“ã«æ„è­˜ã‚’å‘ã‘ã‚‹ã¹ãã§ã™ã‹ï¼Ÿ",
				question2: "ã“ã®é–¢ä¿‚ã¯ä»Šä½•ã‚’å¿…è¦ã¨ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ",
				question3: "ç§ã¯æ­£ã—ã„é“ã‚’æ­©ã‚“ã§ã„ã¾ã™ã‹ï¼Ÿ",
				riderWaite: "ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¦ã‚§ã‚¤ãƒˆã‚¯ãƒ©ã‚·ãƒƒã‚¯",
				artistic: "ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚¿ãƒ­ãƒƒãƒˆ",
				miro: "ãƒŸãƒ­ã‚·ãƒ¥ãƒ«ãƒ¬ã‚¢ãƒªã‚ºãƒ ",
				drawAnother: "åˆ¥ã®ã‚«ãƒ¼ãƒ‰ã‚’å¼•ã",
				changeDeck: "åˆ¥ã®ãƒ‡ãƒƒã‚­ã‚’é¸æŠž",
				upright: "æ­£ä½ç½®",
				reversed: "é€†ä½ç½®"
			},
			ko: {
				title: "ì˜¤ëŠ˜ì˜ ì¹´ë“œ",
				subtitle: "ë¦¬ë”©ì„ ì‹œìž‘í•˜ë ¤ë©´ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ì„¸ìš”",
				chooseYourDeck: "ë¦¬ë”©ì„ ì‹œìž‘í•˜ë ¤ë©´ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ì„¸ìš”",
				question1: "ì˜¤ëŠ˜ ì–´ë””ì— ì˜ë„ë¥¼ ì§‘ì¤‘í•´ì•¼ í• ê¹Œìš”?",
				question2: "ì´ ê´€ê³„ëŠ” ì§€ê¸ˆ ë¬´ì—‡ì´ í•„ìš”í• ê¹Œìš”?",
				question3: "ë‚˜ëŠ” ì˜¬ë°”ë¥¸ ê¸¸ì„ ê°€ê³  ìžˆë‚˜ìš”?",
				deckSubtitle: "ë¦¬ë”©ì„ ìœ„í•œ ì˜ˆìˆ  ìŠ¤íƒ€ì¼ ì„ íƒ",
				riderWaite: "ë¼ì´ë” ì›¨ì´íŠ¸ í´ëž˜ì‹",
				artistic: "ì•„í‹°ìŠ¤í‹± íƒ€ë¡œ",
				miro: "ë¯¸ë¡œ ì´ˆí˜„ì‹¤ì£¼ì˜",
				drawAnother: "ë‹¤ë¥¸ ì¹´ë“œ ë½‘ê¸°",
				changeDeck: "ë‹¤ë¥¸ ë± ì„ íƒ",
				upright: "ì •ë°©í–¥",
				reversed: "ì—­ë°©í–¥"
			}
		};

		// Load saved language preference or default to English
		let currentLanguage = localStorage.getItem('tarotLanguage') || 'en';
		let currentDeck = null;
		let currentCard = null;
		let currentIsReversed = false;
		let currentQuestionIndex = 0;
		const questions = [
			"Where should I focus my intention today?",
			"What does this relationship need right now?",
			"Am I on the right track?"
		];
		let currentQuestion = questions[0];
		let readingsData = {
			miro: null,
			artistic: null,
			rider: null
		};

		// Shuffle animation variables
		let animCards = [];
		let isAnimating = false;
		let canPickCard = false;
		let selectedCardElement = null;
		let selectedCardScale = 1;
		let selectedCardTopPosition = 0;

		// Load reading JSON files
		async function loadReadings() {
			try {
				const [miroResponse, artisticResponse, riderResponse] = await Promise.all([
					fetch('data/miro-readings.json'),
					fetch('data/artistic-readings.json'),
					fetch('data/rider-readings.json')
				]);

				readingsData.miro = await miroResponse.json();
				readingsData.artistic = await artisticResponse.json();
				readingsData.rider = await riderResponse.json();

				console.log('Readings loaded successfully');
			} catch (error) {
				console.error('Error loading readings:', error);
			}
		}

		// Cycle through questions with animation
		function cycleQuestion() {
			const questionText = document.getElementById('question-text');

			// Start swipe out animation
			questionText.classList.add('swipe-out-right');

			// After animation completes, change text and swipe in
			setTimeout(() => {
				currentQuestionIndex = (currentQuestionIndex + 1) % questions.length;
				currentQuestion = questions[currentQuestionIndex]; // Keep English for reading lookup

				// Display translated question
				const trans = translations[currentLanguage];
				const questionKey = `question${currentQuestionIndex + 1}`;
				questionText.textContent = trans[questionKey];

				// Remove swipe out and add swipe in
				questionText.classList.remove('swipe-out-right');
				questionText.classList.add('swipe-in-left');

				// Clean up animation class after it completes
				setTimeout(() => {
					questionText.classList.remove('swipe-in-left');
				}, 400);
			}, 400);
		}

		// Helper function to get card meaning from Rider-Waite data
		function getCardMeaning(cardName) {
			if (!riderWaiteData || !riderWaiteData.meanings) return null;

			// Check major arcana
			const majorCard = riderWaiteData.meanings.major_arcana.find(c => c.name === cardName);
			if (majorCard) {
				return {
					upright: majorCard.upright,
					reversed: majorCard.reversed,
					type: 'major'
				};
			}

			// Check minor arcana
			for (const suit in riderWaiteData.meanings.minor_arcana) {
				const minorCard = riderWaiteData.meanings.minor_arcana[suit].find(c => c.name === cardName);
				if (minorCard) {
					return {
						upright: minorCard.upright,
						reversed: minorCard.reversed,
						type: 'minor',
						suit: suit
					};
				}
			}

			return null;
		}

		// Generate daily advice based on card meaning
		async function generateDailyAdvice(cardName, meaning, isReversed, language = 'en') {
			const meaningTextEn = isReversed ? meaning.reversed : meaning.upright;

			// First, generate the English reading
			const templates = {
				reversed_major: `Today, pay attention to ${meaningTextEn}. This energy is blocked or working internally. Take time for introspection and address what's holding you back from within.`,
				reversed_minor: `Today's guidance: ${meaningTextEn} needs your attention. Something in this area is blocked or out of balance. Face it honestly and work to restore flow.`,
				upright_major: `Today brings the powerful energy of ${meaningTextEn}. Embrace this theme fully - it holds an important lesson or opportunity for you. Let it guide your choices.`,
				upright_minor: `Today's message: ${meaningTextEn}. Lean into this energy and let it shape your day. This is what's most important for you to focus on right now.`
			};

			let englishReading;
			if (isReversed) {
				englishReading = meaning.type === 'major' ? templates.reversed_major : templates.reversed_minor;
			} else {
				englishReading = meaning.type === 'major' ? templates.upright_major : templates.upright_minor;
			}

			// If English, return directly
			if (language === 'en') {
				return englishReading;
			}

			// For other languages, translate the entire English reading
			return await translateText(englishReading, language);
		}

		// Simple translation function using Google Translate API or fallback
		async function translateText(text, targetLang) {
			// Try using Google Translate API (requires API key)
			try {
				const response = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`);
				const data = await response.json();

				if (data && data[0] && data[0][0] && data[0][0][0]) {
					// Combine all translated segments
					return data[0].map(segment => segment[0]).join('');
				}
			} catch (error) {
				console.warn('Translation failed, using English:', error);
			}

			// Fallback: return English if translation fails
			return text;
		}

		// ===== SHUFFLE ANIMATION FUNCTIONS =====

		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		function setInstruction(text) {
			const instruction = document.getElementById('shuffle-instruction');
			if (instruction) {
				instruction.textContent = text;
			}
		}

		function createAnimatedCard(index, tarotCard) {
			const card = document.createElement('div');
			card.className = 'anim-card';
			card.dataset.index = index;
			card.dataset.cardName = tarotCard.name;

			const cardInner = document.createElement('div');
			cardInner.className = 'anim-card-inner';

			// Card face (front) - use thumbnail for faster loading
			const cardFace = document.createElement('div');
			cardFace.className = 'anim-card-face';
			const deckIdMap = {
				'rider': 'rider-waite',
				'artistic': 'artistic',
				'miro': 'miro'
			};
			const deckId = deckIdMap[currentDeck] || 'rider-waite';

			// Use thumbnail image for better performance during shuffle
			const imagePath = DeckLoader.getImagePath(deckId, tarotCard, true); // true for thumbnail
			const cardImg = document.createElement('img');
			cardImg.src = imagePath;
			cardImg.alt = tarotCard.name;
			cardImg.loading = 'eager'; // Load immediately for smoother animation
			cardFace.appendChild(cardImg);

			// Card back - deck-specific image with fallback
			const cardBack = document.createElement('div');
			cardBack.className = 'anim-card-back';

			// Get deck-specific card back image path
			const cardBackPaths = {
				'rider': 'decks/images/card-back.png',
				'artistic': 'decks/artistic-tarot-cards/card-back.png',
				'miro': 'decks/miro-tarot-cards/card-back.png'
			};
			const cardBackPath = cardBackPaths[currentDeck] || 'decks/images/card-back.png';

			// Create image element with error fallback
			const cardBackImg = document.createElement('img');
			cardBackImg.src = cardBackPath;
			cardBackImg.alt = 'Card Back';
			cardBackImg.loading = 'eager'; // Load immediately for visible cards
			cardBackImg.style.cssText = 'width: 100%; height: 100%; object-fit: cover; border-radius: 8px;';

			// Fallback to CSS gradient if image fails to load
			cardBackImg.onerror = function() {
				cardBack.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
				cardBack.style.border = '3px solid #d4af37';
				cardBack.innerHTML = '<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-size: 2em;">ðŸ”®</div>';
			};

			cardBack.appendChild(cardBackImg);

			cardInner.appendChild(cardFace);
			cardInner.appendChild(cardBack);
			card.appendChild(cardInner);

			// Initial position (center, stacked)
			card.style.left = '50%';
			card.style.top = '50%';
			card.style.transform = 'translate(-50%, -50%)';
			card.style.zIndex = index;

			card.addEventListener('click', () => selectAnimatedCard(card, tarotCard));

			return card;
		}

		function createShuffleDeck() {
			const container = document.getElementById('animation-area');

			// Preserve the shuffle instruction element
			const instruction = document.getElementById('shuffle-instruction');

			// Clear all existing cards explicitly before clearing innerHTML
			const existingCards = container.querySelectorAll('.anim-card');
			existingCards.forEach(card => {
				if (card.parentNode) {
					card.parentNode.removeChild(card);
				}
			});

			container.innerHTML = '';

			// Re-append the instruction if it exists
			if (instruction) {
				container.appendChild(instruction);
			}

			animCards = [];

			// Get all cards from DeckLoader
			const allTarotCards = DeckLoader.getAllCards();
			const shuffledTarot = [...allTarotCards].sort(() => Math.random() - 0.5);

			// Create cards for animation - fewer on mobile for better performance
			const isMobile = window.innerWidth <= 768;
			const numCards = isMobile ? 30 : 50;

			for (let i = 0; i < numCards; i++) {
				const tarotCard = shuffledTarot[i % shuffledTarot.length];
				const card = createAnimatedCard(i, tarotCard);
				container.appendChild(card);
				animCards.push(card);
			}
		}

		async function riffleShuffleAnimation(speed = 'normal') {
			const halfLength = Math.floor(animCards.length / 2);

			// Speed presets
			const speeds = {
				fast: { split: 200, pause: 100, interleave: 4 },
				normal: { split: 800, pause: 500, interleave: 50 }
			};

			const timing = speeds[speed] || speeds.normal;

			// Split deck into two halves
			const leftHalf = animCards.slice(0, halfLength);
			const rightHalf = animCards.slice(halfLength);
			const splitInterval = timing.split / animCards.length;

			// Position both halves simultaneously
			for (let i = 0; i < Math.max(leftHalf.length, rightHalf.length); i++) {
				if (i < leftHalf.length) {
					leftHalf[i].style.left = 'calc(50% - 150px)';
					leftHalf[i].style.top = '50%';
					leftHalf[i].style.transform = `translate(-50%, -50%) rotate(-5deg)`;
					leftHalf[i].style.zIndex = i;
				}
				if (i < rightHalf.length) {
					rightHalf[i].style.left = 'calc(50% + 150px)';
					rightHalf[i].style.top = '50%';
					rightHalf[i].style.transform = `translate(-50%, -50%) rotate(5deg)`;
					rightHalf[i].style.zIndex = i + halfLength;
				}
				await sleep(splitInterval);
			}

			await sleep(timing.pause);

			// Interleave cards (riffle effect)
			const maxLength = Math.max(leftHalf.length, rightHalf.length);
			for (let i = 0; i < maxLength; i++) {
				if (i < leftHalf.length) {
					leftHalf[i].style.left = '50%';
					leftHalf[i].style.top = '50%';
					leftHalf[i].style.transform = 'translate(-50%, -50%)';
					leftHalf[i].style.zIndex = i * 2;
					await sleep(timing.interleave);
				}
				if (i < rightHalf.length) {
					rightHalf[i].style.left = '50%';
					rightHalf[i].style.top = '50%';
					rightHalf[i].style.transform = 'translate(-50%, -50%)';
					rightHalf[i].style.zIndex = i * 2 + 1;
					await sleep(timing.interleave);
				}
			}
		}

		async function displayCardsInRow() {
			const container = document.getElementById('animation-area');
			const containerRect = container.getBoundingClientRect();
			const containerWidth = containerRect.width;
			const containerHeight = containerRect.height;

			const margin = 80;
			const totalWidth = containerWidth - margin * 2;
			const spacing = Math.min(50, totalWidth / animCards.length);

			const totalCardSpread = (animCards.length - 1) * spacing;
			const startX = (containerWidth - totalCardSpread) / 2;
			const baseY = containerHeight * 0.5; // Center vertically
			const arcHeight = 30;

			for (let i = 0; i < animCards.length; i++) {
				const progress = i / (animCards.length - 1);
				const x = startX + i * spacing;

				const arcOffset = Math.sin(progress * Math.PI) * arcHeight;
				const y = baseY - arcOffset;

				const rotation = (progress - 0.5) * 8;

				animCards[i].style.left = `${x}px`;
				animCards[i].style.top = `${y}px`;
				animCards[i].style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
				animCards[i].style.zIndex = i;
				animCards[i].style.opacity = '1';
				animCards[i].style.pointerEvents = 'auto';

				await sleep(40);
			}
		}

		async function shuffleAnimation() {
			if (isAnimating) return;
			isAnimating = true;
			canPickCard = false;

			setInstruction('Shuffling the cards...');

			// Mark all cards as shuffling
			animCards.forEach(card => card.classList.add('shuffling'));

			// Phase 1: Initial Riffle Shuffle (fast)
			await riffleShuffleAnimation('fast');
			await sleep(400);

			// Phase 2: Infinity Symbol Spread (simplified on mobile to prevent rendering artifacts)
			const spreadInterval = 1000 / animCards.length;
			const isMobile = window.innerWidth <= 768;

			for (let i = 0; i < animCards.length; i++) {
				const progress = i / (animCards.length - 1);

				const t = progress * Math.PI * 8;

				const minScale = 40;
				const maxScale = 220;
				const a = minScale + (maxScale - minScale) * Math.pow(progress, 0.8);

				const sinT = Math.sin(t);
				const cosT = Math.cos(t);
				const denominator = 1 + sinT * sinT;

				const lemniscateX = (a * cosT) / denominator;
				const lemniscateY = (a * sinT * cosT) / denominator;

				const container = document.getElementById('animation-area');
				const containerRect = container.getBoundingClientRect();
				const containerWidth = containerRect.width;
				const containerHeight = containerRect.height;
				const centerX = containerWidth / 2;
				const centerY = containerHeight / 2;

				const x = centerX + lemniscateX;
				const y = centerY + lemniscateY;

				const rotationSpeed = 360 + (progress * 720);
				const rotation = t * (180 / Math.PI) + rotationSpeed;

				const scale = 0.8 + (progress * 0.4);

				animCards[i].style.left = `${x}px`;
				animCards[i].style.top = `${y}px`;

				// Simplified transform for mobile to prevent GPU rendering artifacts
				if (isMobile) {
					animCards[i].style.transform = `translate(-50%, -50%)
						rotate(${rotation}deg)
						scale(${scale})`;
				} else {
					const tiltX = sinT * 15;
					const tiltY = cosT * 10;
					animCards[i].style.transform = `translate(-50%, -50%)
						rotate(${rotation}deg)
						rotateX(${tiltX}deg)
						rotateY(${tiltY}deg)
						scale(${scale})`;
				}

				animCards[i].style.opacity = 0.7 + (progress * 0.3);

				await sleep(spreadInterval);
			}

			await sleep(800);

			// Phase 3: Gather to center (simplified on mobile)
			const gatherInterval = 20;

			for (let i = animCards.length - 1; i >= 0; i--) {
				animCards[i].style.left = '50%';
				animCards[i].style.top = '50%';

				// Simplified transform for mobile to prevent GPU rendering artifacts
				if (isMobile) {
					const rotation = (i % 4) * 90; // Simple rotation variation
					animCards[i].style.transform = `translate(-50%, -50%)
						rotate(${rotation}deg)
						scale(1)`;
				} else {
					const tumbleX = (i % 3 - 1) * 180;
					const tumbleY = (i % 2) * 360;
					animCards[i].style.transform = `translate(-50%, -50%)
						rotateY(${720 + tumbleY}deg)
						rotateX(${tumbleX}deg)
						scale(1)`;
				}

				animCards[i].style.opacity = '1';
				animCards[i].style.zIndex = animCards.length - i;

				await sleep(gatherInterval);
			}

			await sleep(800);

			// Phase 4: Final riffle shuffle
			await riffleShuffleAnimation();

			await sleep(800);

			// Phase 5: Display in row for selection
			setInstruction('Pick a card...');
			await displayCardsInRow();

			// Remove shuffling class
			animCards.forEach(card => card.classList.remove('shuffling'));

			canPickCard = true;
			isAnimating = false;
		}

		// Function to calculate and position card and reading box
		function positionCardAndReadingBox() {
			if (!selectedCardElement) return;

			const isMobile = window.innerWidth <= 768;
			const animArea = document.getElementById('animation-area');
			const animAreaRect = animArea.getBoundingClientRect();

			// Current card dimensions (before scaling)
			const cardWidth = isMobile ? 88 : 132;
			const cardHeight = isMobile ? 132 : 198;

			// Calculate card scale
			let finalScale;
			if (isMobile) {
				// Mobile: scale up to make card large and prominent
				const viewportWidth = window.innerWidth;
				const maxCardWidth = viewportWidth * 0.75; // Card can take 75% of screen width
				const scaleByWidth = maxCardWidth / cardWidth;
				finalScale = Math.min(scaleByWidth, 5); // Much larger max scale
			} else {
				// Desktop: scale to fit nicely in left portion
				const maxDesktopHeight = window.innerHeight * 0.65;
				const scaleByHeight = maxDesktopHeight / cardHeight;
				finalScale = Math.min(scaleByHeight, 3);
			}

			// Store scale for later use
			selectedCardScale = finalScale;

			// Calculate scaled card dimensions
			const scaledCardWidth = cardWidth * finalScale;
			const scaledCardHeight = cardHeight * finalScale;

			// Position card and reading box
			if (isMobile) {
				// MOBILE: Card at top, reading box below it
				// Position card 30px from top of animation area
				const cardTopPosition = 30;
				const cardLeftPosition = animAreaRect.width / 2;

				selectedCardElement.style.left = `${cardLeftPosition}px`;
				selectedCardElement.style.top = `${cardTopPosition}px`;
				selectedCardElement.style.transformOrigin = 'top center'; // Scale from top, not center
				selectedCardElement.style.transform = `translate(-50%, 0) scale(${finalScale})`; // No vertical centering

				// Position reading box below card with 20px gap
				const readingBox = document.getElementById('reading-box');
				if (readingBox) {
					const readingBoxTop = cardTopPosition + scaledCardHeight + 20;

					readingBox.style.left = '5%';
					readingBox.style.right = '5%';
					readingBox.style.top = `${readingBoxTop}px`;
					readingBox.style.width = 'auto';
					readingBox.style.maxHeight = 'none';
					readingBox.style.overflowY = 'visible';
					readingBox.style.zIndex = '1001';

					// Pre-calculate required height to prevent layout shift
					// Use requestAnimationFrame to ensure reading box is rendered
					requestAnimationFrame(() => {
						const readingBoxRect = readingBox.getBoundingClientRect();
						const totalHeight = readingBoxTop + readingBoxRect.height + 40; // 40px bottom padding
						animArea.style.minHeight = `${totalHeight}px`;
					});
				}
			} else {
				// DESKTOP: Card on left, reading box on right, both top-aligned with animation area
				// Position card at 16.67% from left (center of left third)
				const cardLeftPercent = 16.67;

				// Both card and reading box start at top of animation area (0px)
				const readingBoxTopPosition = 0;
				const cardTopPosition = 0;

				selectedCardElement.style.left = `${cardLeftPercent}%`;
				selectedCardElement.style.top = `${cardTopPosition}px`;
				selectedCardElement.style.transformOrigin = 'top center'; // Scale from top, not center
				selectedCardElement.style.transform = `translate(-50%, 0) scale(${finalScale})`; // No vertical centering in transform

				// Store top position for alignment
				selectedCardTopPosition = cardTopPosition;

				// Position reading box on the right
				const readingBox = document.getElementById('reading-box');
				if (readingBox) {
					readingBox.style.left = '38%'; // Start at 38% to create gap
					readingBox.style.right = '2%';
					readingBox.style.top = `${readingBoxTopPosition}px`; // Box starts at top (0px)
					readingBox.style.width = 'auto';
					readingBox.style.maxWidth = 'none';
					readingBox.style.maxHeight = 'none';
					readingBox.style.overflowY = 'visible';
					readingBox.style.zIndex = '500';

					// Pre-calculate required height to prevent layout shift
					requestAnimationFrame(() => {
						const readingBoxRect = readingBox.getBoundingClientRect();
						const totalHeight = Math.max(cardTopPosition + scaledCardHeight, readingBoxTopPosition + readingBoxRect.height) + 60;
						animArea.style.minHeight = `${totalHeight}px`;
					});
				}
			}
		}

		async function selectAnimatedCard(selectedCard, tarotCard) {
			if (!canPickCard || isAnimating) return;

			isAnimating = true;
			canPickCard = false;

			// Randomly select actual card from all 78 cards at moment of click
			const allTarotCards = DeckLoader.getAllCards();
			const randomIndex = Math.floor(Math.random() * allTarotCards.length);
			const actualCard = allTarotCards[randomIndex];

			// Store selected card globally
			selectedCardElement = selectedCard;

			// Fade out instruction text
			const instruction = document.getElementById('shuffle-instruction');
			instruction.classList.add('fade-out');

			// Fade out the animation border immediately on card click
			const animArea = document.getElementById('animation-area');
			animArea.classList.add('fade-border');

			// Mark as selected
			selectedCard.classList.add('selected');

			// Determine if reversed
			const isReversed = Math.random() < 0.3;

			// Make selected card glow
			selectedCard.style.boxShadow = '0 0 40px rgba(255, 255, 255, 1)';
			selectedCard.style.filter = 'brightness(1.3)';

			await sleep(300);

			// Fade out non-selected cards completely
			const unpickedCards = animCards.filter(card => card !== selectedCard);

			for (let i = 0; i < unpickedCards.length; i++) {
				// Immediately hide cards completely to prevent rendering artifacts
				unpickedCards[i].style.transition = 'none';
				unpickedCards[i].style.opacity = '0';
				unpickedCards[i].style.visibility = 'hidden'; // Hide immediately, not later!
				unpickedCards[i].style.display = 'none'; // Remove from layout immediately
				unpickedCards[i].style.transform = 'translate(-50%, -50%) scale(0.3)';
				await sleep(20);
			}

			// Immediately hide and remove unpicked cards to prevent visual artifacts
			unpickedCards.forEach(card => {
				card.style.visibility = 'hidden'; // Hide from rendering
				card.style.display = 'none'; // Hide immediately
				card.style.pointerEvents = 'none'; // Disable all interaction
				if (card.parentNode) {
					card.parentNode.removeChild(card);
				}
			});

			await sleep(500);

			// Allow overflow so card won't be clipped when scaled up
			animArea.classList.add('allow-overflow');

			// Pre-calculate and set animation area height for smooth footer transition
			const isMobile = window.innerWidth <= 768;
			const cardWidth = isMobile ? 88 : 132;
			const cardHeight = isMobile ? 132 : 198;

			// Estimate scale (same logic as in positionCardAndReadingBox)
			let estimatedScale;
			if (isMobile) {
				const viewportWidth = window.innerWidth;
				const maxCardWidth = viewportWidth * 0.75;
				const scaleByWidth = maxCardWidth / cardWidth;
				estimatedScale = Math.min(scaleByWidth, 5);
			} else {
				const maxDesktopHeight = window.innerHeight * 0.65;
				const scaleByHeight = maxDesktopHeight / cardHeight;
				estimatedScale = Math.min(scaleByHeight, 3);
			}

			const scaledCardHeight = cardHeight * estimatedScale;

			if (isMobile) {
				// Mobile: card at top (30px) + scaled height + gap (20px) + reading box estimate (500px) + buffer (100px)
				const estimatedHeight = 30 + scaledCardHeight + 20 + 500 + 100;
				animArea.style.minHeight = `${estimatedHeight}px`;
			} else {
				// Desktop: max of card or reading box height + buffer
				const estimatedHeight = Math.max(scaledCardHeight, 600) + 100;
				animArea.style.minHeight = `${estimatedHeight}px`;
			}

			// Position card using new function with enhanced depth shadow and golden glow
			selectedCard.style.boxShadow = `
				0 0 40px rgba(212, 175, 55, 0.6),
				0 0 80px rgba(212, 175, 55, 0.3),
				0 20px 60px rgba(0, 0, 0, 0.4),
				0 10px 30px rgba(0, 0, 0, 0.3),
				0 5px 15px rgba(0, 0, 0, 0.2),
				0 0 0 1px rgba(255, 255, 255, 0.1)
			`;
			selectedCard.style.zIndex = 1000;
			selectedCard.style.transition = 'all 0.8s ease';
			positionCardAndReadingBox();

			await sleep(800);

			// Update card face to show the randomly selected card and wait for it to load
			const deckIdMap = {
				'rider': 'rider-waite',
				'artistic': 'artistic',
				'miro': 'miro'
			};
			const deckId = deckIdMap[currentDeck] || 'rider-waite';
			const cardFace = selectedCard.querySelector('.anim-card-face img');
			if (cardFace) {
				const actualImagePath = DeckLoader.getImagePath(deckId, actualCard, true); // Use thumbnail

				// Preload the image before changing src to prevent flicker
				await new Promise((resolve) => {
					const tempImg = new Image();
					tempImg.onload = () => {
						cardFace.src = actualImagePath;
						cardFace.alt = actualCard.name;
						resolve();
					};
					tempImg.onerror = () => {
						// If image fails to load, still update but don't wait
						cardFace.src = actualImagePath;
						cardFace.alt = actualCard.name;
						resolve();
					};
					tempImg.src = actualImagePath;
				});
			}

			// Flip the card to show front
			if (isReversed) {
				selectedCard.classList.add('reversed');
			} else {
				selectedCard.classList.add('flipped');
			}

			await sleep(800);

			// Get reading text using the randomly selected card
			let readingEnglish = getReadingFromJSON(currentDeck, actualCard.name, currentQuestion, isReversed);

			if (!readingEnglish) {
				const meaning = getCardMeaning(actualCard.name);
				if (meaning) {
					readingEnglish = await generateDailyAdvice(actualCard.name, meaning, isReversed, 'en');
				}
			}

			// Translate if needed
			let reading = readingEnglish;
			if (currentLanguage !== 'en') {
				reading = await translateText(readingEnglish, currentLanguage);
			}

			// Store current card info
			currentCard = actualCard;
			currentIsReversed = isReversed;

			// Create and show reading box
			showReadingBox(actualCard, isReversed, reading);

			isAnimating = false;
		}

		function showReadingBox(card, isReversed, reading) {
			const trans = translations[currentLanguage];

			// Remove existing reading box if any
			const existingBox = document.getElementById('reading-box');
			if (existingBox) {
				existingBox.remove();
			}

			// Create reading box
			const readingBox = document.createElement('div');
			readingBox.id = 'reading-box';
			readingBox.innerHTML = `
				<div class="reading-card-name-container">
					<div class="reading-card-name">${card.name}</div>
					<div class="reading-card-orientation">${isReversed ? `(${trans.reversed})` : `(${trans.upright})`}</div>
				</div>
				<div class="reading-text">${reading}</div>
				<div class="reading-buttons">
					<button class="btn-primary" onclick="drawAnotherCard()">
						<span>${trans.drawAnother}</span>
					</button>
					<button class="btn-secondary" onclick="returnToDeckSelection()">
						<span>${trans.changeDeck}</span>
					</button>
				</div>
			`;

			// Append to animation area instead of body
			const animArea = document.getElementById('animation-area');
			animArea.appendChild(readingBox);

			// Position it relative to the card after DOM renders and all animations settle
			// Use requestAnimationFrame to ensure DOM has rendered
			requestAnimationFrame(() => {
				requestAnimationFrame(() => {
					positionCardAndReadingBox();
				});
			});

			// Show with fade in
			setTimeout(() => {
				readingBox.classList.add('show');
			}, 100);
		}

		async function showFinalReading(selectedCard, isReversed) {
			const cardImageContainer = document.getElementById('card-image-container');
			const cardName = document.getElementById('card-name');
			const cardOrientation = document.getElementById('card-orientation');
			const cardReading = document.getElementById('card-reading');

			// Clear previous content
			cardImageContainer.innerHTML = '';
			cardName.textContent = '';
			cardOrientation.textContent = '';
			cardReading.textContent = '';

			// Get reading
			let readingEnglish = getReadingFromJSON(currentDeck, selectedCard.name, currentQuestion, isReversed);

			if (!readingEnglish) {
				const meaning = getCardMeaning(selectedCard.name);
				if (meaning) {
					readingEnglish = await generateDailyAdvice(selectedCard.name, meaning, isReversed, 'en');
				}
			}

			// Translate if needed
			let reading = readingEnglish;
			if (currentLanguage !== 'en') {
				reading = await translateText(readingEnglish, currentLanguage);
			}

			// Store current card info
			currentCard = selectedCard;
			currentIsReversed = isReversed;

			// Render card
			const deckIdMap = {
				'rider': 'rider-waite',
				'artistic': 'artistic',
				'miro': 'miro'
			};
			const deckId = deckIdMap[currentDeck] || 'rider-waite';
			renderCardUnified(deckId, selectedCard, isReversed);

			// Update card info
			const trans = translations[currentLanguage];
			cardName.textContent = selectedCard.name;
			const leftParen = currentLanguage === 'zh' ? 'ï¼ˆ' : '(';
			const rightParen = currentLanguage === 'zh' ? 'ï¼‰' : ')';
			cardOrientation.textContent = isReversed ? `${leftParen}${trans.reversed}${rightParen}` : `${leftParen}${trans.upright}${rightParen}`;
			cardReading.textContent = reading;

			// Show card container with reading already visible
			document.getElementById('card-container').classList.remove('hidden');
			document.getElementById('card-reading').classList.add('revealed');
			document.getElementById('action-buttons').style.display = 'flex';
			document.getElementById('action-buttons').classList.add('revealed');
		}

		// ===== END SHUFFLE ANIMATION FUNCTIONS =====

		async function selectDeck(deckType) {
			currentDeck = deckType;

			// Ensure readings are loaded
			if (!readingsData[deckType]) {
				await loadReadings();
			}

			// Hide deck selection
			const deckSelection = document.getElementById('deck-selection');
			deckSelection.classList.add('fade-out');

			setTimeout(() => {
				deckSelection.style.display = 'none';

				// Show shuffle container and start animation
				const shuffleContainer = document.getElementById('shuffle-container');
				shuffleContainer.classList.remove('hidden');

				// Scroll to show question at top of screen
				const questionContainer = document.getElementById('question-container');
				setTimeout(() => {
					questionContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
				}, 100);

				createShuffleDeck();
				shuffleAnimation();
			}, 500);
		}

		function returnToDeckSelection() {
			// Remove reading box
			const readingBox = document.getElementById('reading-box');
			if (readingBox) {
				readingBox.remove();
			}

			// Hide card display and shuffle container
			document.getElementById('card-container').classList.add('hidden');
			document.getElementById('shuffle-container').classList.add('hidden');

			// Remove fade-out from instruction and preserve it
			const instruction = document.getElementById('shuffle-instruction');
			if (instruction) {
				instruction.classList.remove('fade-out');
			}

			// Clear card content
			document.getElementById('card-image-container').innerHTML = '';
			document.getElementById('card-name').textContent = '';
			document.getElementById('card-orientation').textContent = '';
			document.getElementById('card-reading').textContent = '';
			document.getElementById('card-reading').classList.remove('revealed');
			document.getElementById('action-buttons').style.display = 'none';
			document.getElementById('action-buttons').classList.remove('revealed');

			// Clear animation area and remove fade-border, but preserve instruction
			const animArea = document.getElementById('animation-area');
			animArea.innerHTML = '';
			if (instruction) {
				animArea.appendChild(instruction);
			}
			animArea.classList.remove('fade-border');
			animArea.classList.remove('allow-overflow');
			animArea.style.minHeight = ''; // Reset height to default
			animCards = [];

			// Reset selected card globals
			selectedCardElement = null;
			selectedCardScale = 1;
			selectedCardTopPosition = 0;

			// Show deck selection
			const deckSelection = document.getElementById('deck-selection');
			deckSelection.style.display = 'block';
			deckSelection.classList.remove('fade-out');

			// Reset
			currentDeck = null;
			currentCard = null;
			isAnimating = false;
			canPickCard = false;

			// Scroll to top
			window.scrollTo({ top: 0, behavior: 'smooth' });
		}

		function drawAnotherCard() {
			// Remove reading box
			const readingBox = document.getElementById('reading-box');
			if (readingBox) {
				readingBox.remove();
			}

			// Preserve instruction before clearing
			const instruction = document.getElementById('shuffle-instruction');
			if (instruction) {
				instruction.classList.remove('fade-out');
			}

			// Clear animation area and remove fade-border
			const animArea = document.getElementById('animation-area');
			animArea.innerHTML = '';
			if (instruction) {
				animArea.appendChild(instruction);
			}
			animArea.classList.remove('fade-border');
			animArea.classList.remove('allow-overflow');

			// Reset animation area height to default
			animArea.style.minHeight = '';

			// Reset selected card globals
			selectedCardElement = null;
			selectedCardScale = 1;
			selectedCardTopPosition = 0;

			animCards = [];

			// Hide card display (just in case)
			document.getElementById('card-container').classList.add('hidden');

			// Clear previous card content
			document.getElementById('card-image-container').innerHTML = '';
			document.getElementById('card-name').textContent = '';
			document.getElementById('card-orientation').textContent = '';
			document.getElementById('card-reading').textContent = '';
			document.getElementById('card-reading').classList.remove('revealed');
			document.getElementById('action-buttons').style.display = 'none';
			document.getElementById('action-buttons').classList.remove('revealed');

			// Show shuffle container and start new animation
			document.getElementById('shuffle-container').classList.remove('hidden');

			// Scroll to show question at top of screen
			const questionContainer = document.getElementById('question-container');
			setTimeout(() => {
				questionContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
			}, 100);

			createShuffleDeck();
			shuffleAnimation();
		}

		// Get reading from JSON
		function getReadingFromJSON(deckType, cardName, question, isReversed) {
			const data = readingsData[deckType];
			if (!data || !data.readings) {
				console.error('No readings data for deck:', deckType);
				return null;
			}

			const cardReading = data.readings.find(r => r.card_name === cardName);
			if (!cardReading || !cardReading.questions) {
				console.error('No reading found for card:', cardName);
				return null;
			}

			const questionReading = cardReading.questions[question];
			if (!questionReading) {
				console.error('No reading found for question:', question);
				return null;
			}

			return isReversed ? questionReading.reversed : questionReading.upright;
		}

		function renderCardUnified(deckId, card, isReversed) {
			const container = document.getElementById('card-image-container');
			if (!container) {
				console.error('Card container not found');
				return;
			}

			container.innerHTML = '';
			container.classList.remove('loaded');

			const picture = DeckLoader.createResponsiveImage(deckId, card, {
				thumbnail: true,
				loading: 'eager',
				className: isReversed ? 'reversed' : ''
			});

			const img = picture.querySelector('img');

			DeckLoader.addErrorHandler(img);

			if (typeof PerformanceMonitor !== 'undefined') {
				PerformanceMonitor.measureImageLoad(img, deckId, card.name);
			}

			img.onload = () => {
				container.classList.add('loaded');
			};

			img.onerror = () => {
				container.classList.add('loaded');
			};

			container.appendChild(picture);
		}

		function changeLanguage() {
			currentLanguage = document.getElementById('language-select').value;

			const mobileSelect = document.getElementById('language-select-mobile');
			if (mobileSelect) mobileSelect.value = currentLanguage;

			localStorage.setItem('tarotLanguage', currentLanguage);
			updateUILanguage();
		}

		function changeMobileLanguage() {
			currentLanguage = document.getElementById('language-select-mobile').value;

			document.getElementById('language-select').value = currentLanguage;

			localStorage.setItem('tarotLanguage', currentLanguage);
			updateUILanguage();
		}

		async function updateUILanguage() {
			const trans = translations[currentLanguage];

			document.getElementById('card-of-today').textContent = trans.title;
			document.getElementById('subtitle').textContent = trans.subtitle;

			const questionKey = `question${currentQuestionIndex + 1}`;
			document.getElementById('question-text').textContent = trans[questionKey];

			const elements = document.querySelectorAll('[data-translate]');
			elements.forEach(el => {
				const key = el.getAttribute('data-translate');
				if (trans[key]) {
					if (el.tagName === 'INPUT' || el.tagName === 'BUTTON') {
						el.value = trans[key];
					} else {
						el.textContent = trans[key];
					}
				}
			});

			if (currentCard && currentIsReversed !== null) {
				let readingEnglish = getReadingFromJSON(currentDeck, currentCard.name, currentQuestion, currentIsReversed);

				if (!readingEnglish) {
					const meaning = getCardMeaning(currentCard.name);
					if (meaning) {
						readingEnglish = await generateDailyAdvice(currentCard.name, meaning, currentIsReversed, 'en');
					}
				}

				if (readingEnglish) {
					let reading = readingEnglish;
					if (currentLanguage !== 'en') {
						reading = await translateText(readingEnglish, currentLanguage);
					}
					document.getElementById('card-reading').textContent = reading;

					const cardOrientation = document.getElementById('card-orientation');
					const leftParen = currentLanguage === 'zh' ? 'ï¼ˆ' : '(';
					const rightParen = currentLanguage === 'zh' ? 'ï¼‰' : ')';
					cardOrientation.textContent = currentIsReversed ? `${leftParen}${trans.reversed}${rightParen}` : `${leftParen}${trans.upright}${rightParen}`;
				}
			}
		}

		// Initialize
		window.onload = function() {
			loadReadings();

			setTimeout(function() {
				const navPanel = document.querySelector('#navPanel nav');
				if (navPanel && !document.getElementById('language-select-mobile')) {
					const mobileDropdownHTML = `
						<div class="link depth-0" style="padding: 1em; border-top: solid 1px rgba(255, 255, 255, 0.05);">
							<select id="language-select-mobile" onchange="changeMobileLanguage()" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); color: white; font-size: 0.9em;">
								<option value="en">ðŸ‡¬ðŸ‡§ English</option>
								<option value="fr">ðŸ‡«ðŸ‡· FranÃ§ais</option>
								<option value="es">ðŸ‡ªðŸ‡¸ EspaÃ±ol</option>
								<option value="zh">ðŸ‡¨ðŸ‡³ ä¸­æ–‡</option>
								<option value="ja">ðŸ‡¯ðŸ‡µ æ—¥æœ¬èªž</option>
								<option value="ko">ðŸ‡°ðŸ‡· í•œêµ­ì–´</option>
							</select>
						</div>
					`;
					navPanel.insertAdjacentHTML('beforeend', mobileDropdownHTML);

					const mobileSelect = document.getElementById('language-select-mobile');
					if (mobileSelect) mobileSelect.value = currentLanguage;
				}
			}, 150);

			document.getElementById('language-select').value = currentLanguage;

			updateUILanguage();

			console.log('Page loaded. Please select a deck to begin.');
		};
		</script>
	</body>
</html>
