<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Card Picker - Tarot Reading</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Apple Chancery', cursive, serif;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            perspective: 1500px;
            position: relative;
            width: 100%;
            min-height: 500px;
            max-width: 1400px;
        }

        .card {
            position: absolute;
            width: 120px;
            height: 180px;
            border-radius: 8px;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover:not(.shuffling):not(.selected) {
            z-index: 1000 !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8) !important;
            filter: brightness(1.3);
        }

        .card.selected {
            pointer-events: none;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.8s;
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card.reversed .card-inner {
            transform: rotateY(180deg) rotate(180deg);
        }

        .card-face,
        .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .card-face {
            background: white;
            transform: rotateY(180deg);
        }

        .card-face img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        .card-back {
            background: white;
            position: relative;
            overflow: hidden;
        }

        .card-back img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-size: 2.5em;
            text-align: center;
        }

        .instruction {
            color: white;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            min-height: 30px;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
        }

        .instruction.show {
            opacity: 1;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        button {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5);
            font-family: 'Apple Chancery', cursive, serif;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.7);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-count-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .card-count-selector label {
            color: white;
            font-size: 1.2em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .card-count-selector select {
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.95);
            cursor: pointer;
            font-family: 'Apple Chancery', cursive, serif;
        }

        .selected-cards-display {
            margin-top: 40px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            display: none;
        }

        .selected-cards-display.show {
            display: block;
            animation: fadeInUp 0.6s ease;
        }

        .selected-cards-display h2 {
            color: #4c5c96;
            margin-bottom: 20px;
            text-align: center;
            font-size: 2em;
        }

        .selected-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 30px;
            margin-top: 20px;
        }

        .selected-card-item {
            text-align: center;
        }

        .selected-card-item img {
            width: 100%;
            max-width: 200px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }

        .selected-card-item.reversed img {
            transform: rotate(180deg);
        }

        .selected-card-item h3 {
            color: #4c5c96;
            font-size: 1.3em;
            margin-bottom: 5px;
        }

        .selected-card-item p {
            color: #666;
            font-style: italic;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .hidden {
            display: none !important;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .card {
                width: 80px;
                height: 120px;
            }

            button {
                padding: 12px 30px;
                font-size: 16px;
            }

            .instruction {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <h1>ðŸ”® Animated Tarot Card Reading</h1>

    <div class="controls">
        <div class="card-count-selector">
            <label for="card-count">Reading Type:</label>
            <select id="card-count">
                <option value="1">1 Card Reading</option>
                <option value="3" selected>3 Card Reading</option>
            </select>
        </div>
        <button id="shuffleBtn">Shuffle Cards</button>
    </div>

    <div class="instruction" id="instruction"></div>
    <div class="container" id="container"></div>

    <div class="selected-cards-display" id="selectedDisplay">
        <h2>Your Reading</h2>
        <div class="selected-cards-grid" id="selectedGrid"></div>
        <div style="text-align: center; margin-top: 30px;">
            <button onclick="resetReading()">Start New Reading</button>
        </div>
    </div>

    <!-- Load card data -->
    <script src="../decks/rider-waite-data.js"></script>

    <script>
        const container = document.getElementById('container');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const instruction = document.getElementById('instruction');
        const selectedDisplay = document.getElementById('selectedDisplay');
        const selectedGrid = document.getElementById('selectedGrid');
        const cardCountSelect = document.getElementById('card-count');

        let cards = [];
        let allTarotCards = [];
        let isAnimating = false;
        let canPickCard = false;
        let selectedCards = [];
        let numCardsToSelect = 3;

        // Load all tarot cards from Rider-Waite data
        function loadTarotDeck() {
            if (typeof riderWaiteData !== 'undefined') {
                allTarotCards = [...riderWaiteData.cards.major, ...riderWaiteData.cards.minor];
                console.log(`Loaded ${allTarotCards.length} tarot cards`);
            } else {
                console.error('Rider-Waite data not loaded');
            }
        }

        function createCard(index, tarotCard) {
            const card = document.createElement('div');
            card.className = 'card';
            card.dataset.index = index;
            card.dataset.cardName = tarotCard.name;

            const cardInner = document.createElement('div');
            cardInner.className = 'card-inner';

            // Card face (front) - will show tarot image
            const cardFace = document.createElement('div');
            cardFace.className = 'card-face';
            const imagePath = riderWaiteData.getImagePath(tarotCard);
            cardFace.innerHTML = `<img src="../${imagePath}" alt="${tarotCard.name}">`;

            // Card back
            const cardBack = document.createElement('div');
            cardBack.className = 'card-back';
            cardBack.innerHTML = `<img src="../../card animation/rider-waite-1910-card-back.jpg" alt="Card Back">`;

            cardInner.appendChild(cardFace);
            cardInner.appendChild(cardBack);
            card.appendChild(cardInner);

            // Initial position (center, stacked)
            card.style.left = '50%';
            card.style.top = '50%';
            card.style.transform = 'translate(-50%, -50%)';
            card.style.zIndex = index;

            card.addEventListener('click', () => selectCard(card, tarotCard));

            return card;
        }

        function createDeck() {
            container.innerHTML = '';
            cards = [];
            selectedCards = [];
            selectedDisplay.classList.remove('show');

            numCardsToSelect = parseInt(cardCountSelect.value);

            // Shuffle the tarot deck
            const shuffledTarot = [...allTarotCards].sort(() => Math.random() - 0.5);

            // Create 50 cards for a more impressive shuffle animation
            const numCards = 50;

            for (let i = 0; i < numCards; i++) {
                const tarotCard = shuffledTarot[i % shuffledTarot.length];
                const card = createCard(i, tarotCard);
                container.appendChild(card);
                cards.push(card);
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function setInstruction(text) {
            instruction.textContent = text;
            instruction.classList.add('show');
        }

        function clearInstruction() {
            instruction.classList.remove('show');
        }

        async function shuffleAnimation() {
            if (isAnimating) return;
            isAnimating = true;
            canPickCard = false;
            shuffleBtn.disabled = true;

            setInstruction('Shuffling the cards...');

            // Mark all cards as shuffling
            cards.forEach(card => card.classList.add('shuffling'));

            // Phase 1: Spread cards in 2 concentric circles (600ms total)
            const cardsPerRing = 25; // 25 cards per ring for 50 total
            const spreadInterval = 600 / cards.length; // Distribute 600ms across all cards

            for (let i = 0; i < cards.length; i++) {
                const ringIndex = Math.floor(i / cardsPerRing); // 0 or 1
                const cardInRing = i % cardsPerRing;
                const angle = (cardInRing / cardsPerRing) * Math.PI * 2;
                const radius = 200 + ringIndex * 150; // Inner: 200px, Outer: 350px
                const x = window.innerWidth / 2 + Math.cos(angle) * radius;
                const y = 300 + Math.sin(angle) * radius * 0.5;

                cards[i].style.left = `${x}px`;
                cards[i].style.top = `${y}px`;
                cards[i].style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg)`;

                await sleep(spreadInterval);
            }

            await sleep(500);

            // Phase 2: Gather to center
            for (let i = 0; i < cards.length; i++) {
                cards[i].style.left = '50%';
                cards[i].style.top = '50%';
                cards[i].style.transform = 'translate(-50%, -50%) rotateY(720deg)';
                cards[i].style.zIndex = i;
                await sleep(10);
            }

            await sleep(500);

            // Phase 3: Riffle shuffle effect
            await riffleShuffleAnimation();

            await sleep(500);

            // Phase 4: Display in a row for selection
            setInstruction(`Pick ${numCardsToSelect} card${numCardsToSelect > 1 ? 's' : ''}...`);
            await displayCardsInRow();

            // Remove shuffling class
            cards.forEach(card => card.classList.remove('shuffling'));

            canPickCard = true;
            isAnimating = false;
        }

        async function riffleShuffleAnimation() {
            const halfLength = Math.floor(cards.length / 2);

            // Split deck into two halves (300ms total)
            const leftHalf = cards.slice(0, halfLength);
            const rightHalf = cards.slice(halfLength);
            const splitInterval = 300 / cards.length; // Distribute 300ms across all cards

            // Position both halves simultaneously
            for (let i = 0; i < Math.max(leftHalf.length, rightHalf.length); i++) {
                if (i < leftHalf.length) {
                    leftHalf[i].style.left = 'calc(50% - 80px)';
                    leftHalf[i].style.top = '50%';
                    leftHalf[i].style.transform = `translate(-50%, -50%) rotate(-5deg)`;
                    leftHalf[i].style.zIndex = i;
                }
                if (i < rightHalf.length) {
                    rightHalf[i].style.left = 'calc(50% + 80px)';
                    rightHalf[i].style.top = '50%';
                    rightHalf[i].style.transform = `translate(-50%, -50%) rotate(5deg)`;
                    rightHalf[i].style.zIndex = i + halfLength;
                }
                await sleep(splitInterval);
            }

            await sleep(300);

            // Interleave cards (riffle effect)
            const maxLength = Math.max(leftHalf.length, rightHalf.length);
            for (let i = 0; i < maxLength; i++) {
                if (i < leftHalf.length) {
                    leftHalf[i].style.left = '50%';
                    leftHalf[i].style.top = '50%';
                    leftHalf[i].style.transform = 'translate(-50%, -50%)';
                    leftHalf[i].style.zIndex = i * 2;
                    await sleep(30);
                }
                if (i < rightHalf.length) {
                    rightHalf[i].style.left = '50%';
                    rightHalf[i].style.top = '50%';
                    rightHalf[i].style.transform = 'translate(-50%, -50%)';
                    rightHalf[i].style.zIndex = i * 2 + 1;
                    await sleep(30);
                }
            }
        }

        async function displayCardsInRow() {
            // Display all 30 cards in a slight overlapping arc/stack
            const cardsToDisplay = cards; // Show all cards
            const containerWidth = window.innerWidth;
            const cardWidth = 120;

            // Create a gentle arc with overlapping cards
            const totalWidth = Math.min(containerWidth - 100, 1200);
            const spacing = Math.min(50, totalWidth / cardsToDisplay.length); // Overlap cards

            const startX = (containerWidth - (cardsToDisplay.length - 1) * spacing) / 2;
            const baseY = 300;
            const arcHeight = 40; // Height of the arc curve

            for (let i = 0; i < cardsToDisplay.length; i++) {
                // Calculate position along an arc
                const progress = i / (cardsToDisplay.length - 1); // 0 to 1
                const x = startX + i * spacing;

                // Create gentle arc using sine wave
                const arcOffset = Math.sin(progress * Math.PI) * arcHeight;
                const y = baseY - arcOffset;

                // Slight rotation for visual interest
                const rotation = (progress - 0.5) * 8; // -4 to +4 degrees

                cardsToDisplay[i].style.left = `${x}px`;
                cardsToDisplay[i].style.top = `${y}px`;
                cardsToDisplay[i].style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                cardsToDisplay[i].style.zIndex = i;
                cardsToDisplay[i].style.opacity = '1';
                cardsToDisplay[i].style.pointerEvents = 'auto';

                // Store base transform for hover effect
                cardsToDisplay[i].dataset.baseTransform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                cardsToDisplay[i].dataset.baseY = y;

                // Hover effect handled by CSS (no lifting, just highlight)

                await sleep(20);
            }
        }

        async function selectCard(selectedCard, tarotCard) {
            if (!canPickCard || isAnimating) return;

            // Check if already selected
            if (selectedCards.some(sc => sc.element === selectedCard)) return;

            // Check if we've reached the limit
            if (selectedCards.length >= numCardsToSelect) {
                setInstruction('You have already selected all cards!');
                return;
            }

            // Mark as selected to prevent further clicks
            selectedCard.classList.add('selected');

            // Determine if card is reversed (30% chance)
            const isReversed = Math.random() < 0.3;

            // Make selected card glow (no flip yet, no lift)
            selectedCard.style.boxShadow = '0 0 40px rgba(255, 215, 0, 1)';
            selectedCard.style.filter = 'brightness(1.3)';

            await sleep(300);

            // Store selected card (no flip animation here)
            selectedCards.push({
                element: selectedCard,
                card: tarotCard,
                reversed: isReversed
            });

            // Check if all cards selected
            if (selectedCards.length === numCardsToSelect) {
                await sleep(500);
                await showFinalReading();
            } else {
                setInstruction(`Pick ${numCardsToSelect - selectedCards.length} more card${numCardsToSelect - selectedCards.length > 1 ? 's' : ''}...`);
            }
        }

        async function showFinalReading() {
            isAnimating = true;
            canPickCard = false;
            clearInstruction();

            // Phase 1: Gradually fade out all non-selected cards
            setInstruction('Revealing your chosen cards...');
            const unpickedCards = cards.filter(card => !selectedCards.some(sc => sc.element === card));

            for (let i = 0; i < unpickedCards.length; i++) {
                unpickedCards[i].style.opacity = '0';
                unpickedCards[i].style.transform = 'translate(-50%, -50%) scale(0.5) rotate(90deg)';
                await sleep(30);
            }

            await sleep(500);

            // Phase 2: Move picked cards to center
            clearInstruction();
            const centerX = window.innerWidth / 2;
            const centerY = 300;
            const cardSpacing = 180; // Spacing between cards in center

            // Reorder cards for 3-card reading: [0, 1, 2] â†’ [1, 0, 2] (center, left, right)
            let orderedCards = selectedCards;
            if (selectedCards.length === 3) {
                orderedCards = [selectedCards[1], selectedCards[0], selectedCards[2]];
            }

            for (let i = 0; i < orderedCards.length; i++) {
                const selectedCard = orderedCards[i];
                let xOffset = 0;

                if (orderedCards.length === 1) {
                    xOffset = 0;
                } else if (orderedCards.length === 3) {
                    // For 3 cards: center (i=0), left (i=1), right (i=2)
                    if (i === 0) xOffset = 0;           // Center
                    else if (i === 1) xOffset = -cardSpacing; // Left
                    else if (i === 2) xOffset = cardSpacing;  // Right
                } else {
                    // For multiple cards: spread evenly
                    xOffset = (i - (orderedCards.length - 1) / 2) * cardSpacing;
                }

                selectedCard.element.style.left = `${centerX + xOffset}px`;
                selectedCard.element.style.top = `${centerY}px`;
                selectedCard.element.style.transform = 'translate(-50%, -50%) scale(1.3)';
                selectedCard.element.style.boxShadow = '0 0 50px rgba(255, 215, 0, 1)';
                selectedCard.element.style.zIndex = 1000 + i;

                // Flip the card now (during move to center)
                if (selectedCard.reversed) {
                    selectedCard.element.classList.add('reversed');
                } else {
                    selectedCard.element.classList.add('flipped');
                }

                await sleep(300);
            }

            await sleep(800);

            // Phase 3: Display selected cards in the grid
            selectedGrid.innerHTML = '';
            selectedCards.forEach((selectedCard, index) => {
                const cardItem = document.createElement('div');
                cardItem.className = `selected-card-item ${selectedCard.reversed ? 'reversed' : ''}`;

                const imagePath = riderWaiteData.getImagePath(selectedCard.card);
                const orientationText = selectedCard.reversed ? '(Reversed)' : '(Upright)';

                cardItem.innerHTML = `
                    <img src="../${imagePath}" alt="${selectedCard.card.name}">
                    <h3>${selectedCard.card.name}</h3>
                    <p>${orientationText}</p>
                `;

                selectedGrid.appendChild(cardItem);
            });

            // Fade out center cards and show final reading
            await sleep(500);
            selectedCards.forEach(sc => {
                sc.element.style.opacity = '0';
                sc.element.style.transform = 'translate(-50%, -50%) scale(0)';
            });

            await sleep(500);

            selectedDisplay.classList.add('show');
            isAnimating = false;
        }

        function resetReading() {
            // Hide selected display
            selectedDisplay.classList.remove('show');

            // Clear container
            container.innerHTML = '';
            cards = [];
            selectedCards = [];

            // Re-enable button
            shuffleBtn.disabled = false;
            clearInstruction();
        }

        // Event listeners
        shuffleBtn.addEventListener('click', shuffleAnimation);

        cardCountSelect.addEventListener('change', () => {
            if (!isAnimating) {
                createDeck();
            }
        });

        // Initialize
        window.onload = function() {
            loadTarotDeck();
            createDeck();
            console.log('Animated Card Picker ready. Click "Shuffle Cards" to begin.');
        };
    </script>
</body>
</html>
