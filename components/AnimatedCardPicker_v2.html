<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Card Picker V2 - Enhanced Fancy Spread</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Apple Chancery', cursive, serif;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            perspective: 1500px;
            position: relative;
            width: 100%;
            min-height: 600px;
            max-width: 1400px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.02);
            overflow: hidden; /* Constrain cards within border */
        }

        .card {
            position: absolute;
            width: 120px;
            height: 180px;
            border-radius: 8px;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }


        .card:hover:not(.shuffling):not(.selected) {
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8) !important;
            filter: brightness(1.3);
        }

        .card.selected {
            pointer-events: none;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.8s;
        }

        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card.reversed .card-inner {
            transform: rotateY(180deg) rotate(180deg);
        }

        .card-face,
        .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .card-face {
            background: white;
            transform: rotateY(180deg);
        }

        .card-face img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        .card-back {
            background: white;
            position: relative;
            overflow: hidden;
        }

        .card-back img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-size: 2.5em;
            text-align: center;
        }

        .instruction {
            color: white;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            min-height: 30px;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
        }

        .instruction.show {
            opacity: 1;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        button {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5);
            font-family: 'Apple Chancery', cursive, serif;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.7);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-count-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .card-count-selector label {
            color: white;
            font-size: 1.2em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .card-count-selector select {
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.95);
            cursor: pointer;
            font-family: 'Apple Chancery', cursive, serif;
        }

        .selected-cards-display {
            margin-top: 40px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            display: none;
        }

        .selected-cards-display.show {
            display: block;
            animation: fadeInUp 0.6s ease;
        }

        .selected-cards-display h2 {
            color: #4c5c96;
            margin-bottom: 20px;
            text-align: center;
            font-size: 2em;
        }

        .selected-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 30px;
            margin-top: 20px;
        }

        .selected-card-item {
            text-align: center;
        }

        .selected-card-item img {
            width: 100%;
            max-width: 200px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }

        .selected-card-item.reversed img {
            transform: rotate(180deg);
        }

        .selected-card-item h3 {
            color: #4c5c96;
            font-size: 1.3em;
            margin-bottom: 5px;
        }

        .selected-card-item p {
            color: #666;
            font-style: italic;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .hidden {
            display: none !important;
        }


        /* Responsive design */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .card {
                width: 80px;
                height: 120px;
            }

            button {
                padding: 12px 30px;
                font-size: 16px;
            }

            .instruction {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <h1>ðŸ”® Animated Tarot Card Reading</h1>

    <div class="controls">
        <div class="card-count-selector">
            <label for="card-count">Reading Type:</label>
            <select id="card-count">
                <option value="1">1 Card Reading</option>
                <option value="3" selected>3 Card Reading</option>
            </select>
        </div>
        <button id="shuffleBtn">Shuffle Cards</button>
    </div>

    <div class="instruction" id="instruction"></div>
    <div class="container" id="container"></div>

    <div class="selected-cards-display" id="selectedDisplay">
        <h2>Your Reading</h2>
        <div class="selected-cards-grid" id="selectedGrid"></div>
        <div style="text-align: center; margin-top: 30px;">
            <button onclick="resetReading()">Start New Reading</button>
        </div>
    </div>

    <!-- Load card data -->
    <script src="../decks/rider-waite-data.js"></script>

    <script>
        const container = document.getElementById('container');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const instruction = document.getElementById('instruction');
        const selectedDisplay = document.getElementById('selectedDisplay');
        const selectedGrid = document.getElementById('selectedGrid');
        const cardCountSelect = document.getElementById('card-count');

        let cards = [];
        let allTarotCards = [];
        let isAnimating = false;
        let canPickCard = false;
        let selectedCards = [];
        let numCardsToSelect = 3;

        // Load all tarot cards from Rider-Waite data
        function loadTarotDeck() {
            if (typeof riderWaiteData !== 'undefined') {
                allTarotCards = [...riderWaiteData.cards.major, ...riderWaiteData.cards.minor];
                console.log(`Loaded ${allTarotCards.length} tarot cards`);
            } else {
                console.error('Rider-Waite data not loaded');
            }
        }

        function createCard(index, tarotCard) {
            const card = document.createElement('div');
            card.className = 'card';
            card.dataset.index = index;
            card.dataset.cardName = tarotCard.name;

            const cardInner = document.createElement('div');
            cardInner.className = 'card-inner';

            // Card face (front) - will show tarot image
            const cardFace = document.createElement('div');
            cardFace.className = 'card-face';
            const imagePath = riderWaiteData.getImagePath(tarotCard);
            cardFace.innerHTML = `<img src="../${imagePath}" alt="${tarotCard.name}">`;

            // Card back
            const cardBack = document.createElement('div');
            cardBack.className = 'card-back';
            cardBack.innerHTML = `<img src="../../card animation/rider-waite-1910-card-back.jpg" alt="Card Back">`;

            cardInner.appendChild(cardFace);
            cardInner.appendChild(cardBack);
            card.appendChild(cardInner);

            // Initial position (center, stacked)
            card.style.left = '50%';
            card.style.top = '50%';
            card.style.transform = 'translate(-50%, -50%)';
            card.style.zIndex = index;

            card.addEventListener('click', () => selectCard(card, tarotCard));

            return card;
        }

        function createDeck() {
            container.innerHTML = '';
            cards = [];
            selectedCards = [];
            selectedDisplay.classList.remove('show');

            numCardsToSelect = parseInt(cardCountSelect.value);

            // Shuffle the tarot deck
            const shuffledTarot = [...allTarotCards].sort(() => Math.random() - 0.5);

            // Create 50 cards for a more impressive shuffle animation
            const numCards = 50;

            for (let i = 0; i < numCards; i++) {
                const tarotCard = shuffledTarot[i % shuffledTarot.length];
                const card = createCard(i, tarotCard);
                container.appendChild(card);
                cards.push(card);
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function setInstruction(text) {
            instruction.textContent = text;
            instruction.classList.add('show');
        }

        function clearInstruction() {
            instruction.classList.remove('show');
        }

        async function shuffleAnimation() {
            if (isAnimating) return;
            isAnimating = true;
            canPickCard = false;
            shuffleBtn.disabled = true;

            setInstruction('Shuffling the cards...');

            // Mark all cards as shuffling
            cards.forEach(card => card.classList.add('shuffling'));

            // Phase 0: Initial Riffle Shuffle (400ms total - fast)
            await riffleShuffleAnimation('fast');
            await sleep(400);

            // Phase 1: FANCY SPIRAL VORTEX SPREAD (800ms total - faster)
            const spreadInterval = 800 / cards.length; // Distribute 800ms across all cards
            const totalRevolutions = 3; // Number of spiral rotations

            for (let i = 0; i < cards.length; i++) {
                const progress = i / (cards.length - 1); // 0 to 1

                // Spiral mathematics: radius grows as angle increases
                const spiralTurns = totalRevolutions * progress;
                const angle = spiralTurns * Math.PI * 2;

                // Exponential radius growth for dramatic spiral effect (constrained)
                const minRadius = 30;
                const maxRadius = 250; // Reduced to stay within container
                const radius = minRadius + (maxRadius - minRadius) * Math.pow(progress, 0.8);

                // Calculate position relative to container center (stay within bounds)
                // Use container element's actual width for proper centering
                const containerRect = container.getBoundingClientRect();
                const containerWidth = containerRect.width;
                const containerHeight = 600; // Container height
                const centerX = containerWidth / 2;
                const centerY = containerHeight / 2;

                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius * 0.6; // Elliptical for depth

                // Dynamic rotation: cards spin faster as they go out
                const rotationSpeed = 360 + (progress * 720); // 360Â° to 1080Â°
                const rotation = angle * (180 / Math.PI) + rotationSpeed;

                // 3D tilt effect: cards tilt based on position in spiral
                const tiltX = Math.sin(angle) * 15; // -15Â° to +15Â°
                const tiltY = Math.cos(angle) * 10; // -10Â° to +10Â°

                // Slight scale variation: inner cards smaller, outer cards larger
                const scale = 0.8 + (progress * 0.4); // 0.8 to 1.2

                cards[i].style.left = `${x}px`;
                cards[i].style.top = `${y}px`;
                cards[i].style.transform = `translate(-50%, -50%)
                    rotate(${rotation}deg)
                    rotateX(${tiltX}deg)
                    rotateY(${tiltY}deg)
                    scale(${scale})`;
                cards[i].style.opacity = 0.7 + (progress * 0.3); // Fade in effect

                await sleep(spreadInterval);
            }

            await sleep(800);

            // Phase 2: DRAMATIC GATHER TO CENTER (reverse spiral implosion - slowed down)
            const gatherInterval = 20;

            for (let i = cards.length - 1; i >= 0; i--) {
                // Gather in reverse order for implosion effect
                cards[i].style.left = '50%';
                cards[i].style.top = '50%';

                // Multiple spins as cards return, with 3D tumble
                const tumbleX = (i % 3 - 1) * 180; // Vary tumble per card
                const tumbleY = (i % 2) * 360;
                cards[i].style.transform = `translate(-50%, -50%)
                    rotateY(${720 + tumbleY}deg)
                    rotateX(${tumbleX}deg)
                    scale(1)`;

                cards[i].style.opacity = '1'; // Full opacity when gathering
                cards[i].style.zIndex = cards.length - i; // Reverse stack order

                await sleep(gatherInterval);
            }

            await sleep(800);

            // Phase 3: Riffle shuffle effect
            await riffleShuffleAnimation();

            await sleep(800);

            // Phase 4: Display in a row for selection
            setInstruction(`Pick ${numCardsToSelect} card${numCardsToSelect > 1 ? 's' : ''}...`);
            await displayCardsInRow();

            // Remove shuffling class
            cards.forEach(card => card.classList.remove('shuffling'));

            canPickCard = true;
            isAnimating = false;
        }

        async function riffleShuffleAnimation(speed = 'normal') {
            const halfLength = Math.floor(cards.length / 2);

            // Speed presets
            const speeds = {
                fast: { split: 200, pause: 100, interleave: 4 },      // 400ms total
                normal: { split: 800, pause: 500, interleave: 50 }    // ~4300ms total
            };

            const timing = speeds[speed] || speeds.normal;

            // Split deck into two halves
            const leftHalf = cards.slice(0, halfLength);
            const rightHalf = cards.slice(halfLength);
            const splitInterval = timing.split / cards.length;

            // Position both halves simultaneously
            for (let i = 0; i < Math.max(leftHalf.length, rightHalf.length); i++) {
                if (i < leftHalf.length) {
                    leftHalf[i].style.left = 'calc(50% - 80px)';
                    leftHalf[i].style.top = '50%';
                    leftHalf[i].style.transform = `translate(-50%, -50%) rotate(-5deg)`;
                    leftHalf[i].style.zIndex = i;
                }
                if (i < rightHalf.length) {
                    rightHalf[i].style.left = 'calc(50% + 80px)';
                    rightHalf[i].style.top = '50%';
                    rightHalf[i].style.transform = `translate(-50%, -50%) rotate(5deg)`;
                    rightHalf[i].style.zIndex = i + halfLength;
                }
                await sleep(splitInterval);
            }

            await sleep(timing.pause);

            // Interleave cards (riffle effect)
            const maxLength = Math.max(leftHalf.length, rightHalf.length);
            for (let i = 0; i < maxLength; i++) {
                if (i < leftHalf.length) {
                    leftHalf[i].style.left = '50%';
                    leftHalf[i].style.top = '50%';
                    leftHalf[i].style.transform = 'translate(-50%, -50%)';
                    leftHalf[i].style.zIndex = i * 2;
                    await sleep(timing.interleave);
                }
                if (i < rightHalf.length) {
                    rightHalf[i].style.left = '50%';
                    rightHalf[i].style.top = '50%';
                    rightHalf[i].style.transform = 'translate(-50%, -50%)';
                    rightHalf[i].style.zIndex = i * 2 + 1;
                    await sleep(timing.interleave);
                }
            }
        }

        async function displayCardsInRow() {
            // Display all cards in a slight overlapping arc/stack (constrained to container)
            const cardsToDisplay = cards; // Show all cards

            // Use container's actual dimensions for proper centering
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = 600; // Match container height
            const cardWidth = 120;

            // Create a gentle arc with overlapping cards (with margins)
            const margin = 80; // Keep cards away from edges
            const totalWidth = containerWidth - margin * 2;
            const spacing = Math.min(50, totalWidth / cardsToDisplay.length); // Overlap cards

            // Center the card spread horizontally
            const totalCardSpread = (cardsToDisplay.length - 1) * spacing;
            const startX = (containerWidth - totalCardSpread) / 2; // Center the spread
            const baseY = containerHeight * 0.6; // Position in lower portion of container
            const arcHeight = 30; // Reduced arc height to stay within bounds

            for (let i = 0; i < cardsToDisplay.length; i++) {
                // Calculate position along an arc
                const progress = i / (cardsToDisplay.length - 1); // 0 to 1
                const x = startX + i * spacing;

                // Create gentle arc using sine wave
                const arcOffset = Math.sin(progress * Math.PI) * arcHeight;
                const y = baseY - arcOffset;

                // Slight rotation for visual interest
                const rotation = (progress - 0.5) * 8; // -4 to +4 degrees

                cardsToDisplay[i].style.left = `${x}px`;
                cardsToDisplay[i].style.top = `${y}px`;
                cardsToDisplay[i].style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                cardsToDisplay[i].style.zIndex = i;
                cardsToDisplay[i].style.opacity = '1';
                cardsToDisplay[i].style.pointerEvents = 'auto';

                // Store base transform for hover effect
                cardsToDisplay[i].dataset.baseTransform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                cardsToDisplay[i].dataset.baseY = y;

                // Store shuffle position index for final reveal
                cardsToDisplay[i].dataset.shuffleIndex = i;

                // Hover effect handled by CSS (no lifting, just highlight)

                await sleep(40);
            }
        }

        async function selectCard(selectedCard, tarotCard) {
            if (!canPickCard || isAnimating) return;

            // Check if already selected
            if (selectedCards.some(sc => sc.element === selectedCard)) return;

            // Check if we've reached the limit
            if (selectedCards.length >= numCardsToSelect) {
                setInstruction('You have already selected all cards!');
                return;
            }

            // Mark as selected to prevent further clicks
            selectedCard.classList.add('selected');

            // Determine if card is reversed (30% chance)
            const isReversed = Math.random() < 0.3;

            // Make selected card glow (no flip yet, no lift)
            selectedCard.style.boxShadow = '0 0 40px rgba(255, 215, 0, 1)';
            selectedCard.style.filter = 'brightness(1.3)';

            await sleep(300);

            // Store selected card (no flip animation here)
            selectedCards.push({
                element: selectedCard,
                card: tarotCard,
                reversed: isReversed
            });

            // Check if all cards selected
            if (selectedCards.length === numCardsToSelect) {
                await sleep(500);
                await showFinalReading();
            } else {
                setInstruction(`Pick ${numCardsToSelect - selectedCards.length} more card${numCardsToSelect - selectedCards.length > 1 ? 's' : ''}...`);
            }
        }

        async function showFinalReading() {
            isAnimating = true;
            canPickCard = false;
            clearInstruction();

            // Phase 1: Gradually fade out all non-selected cards
            setInstruction('Revealing your chosen cards...');
            const unpickedCards = cards.filter(card => !selectedCards.some(sc => sc.element === card));

            for (let i = 0; i < unpickedCards.length; i++) {
                unpickedCards[i].style.opacity = '0';
                unpickedCards[i].style.transform = 'translate(-50%, -50%) scale(0.5) rotate(90deg)';
                await sleep(30);
            }

            await sleep(500);

            // Phase 2: Move picked cards to center (based on selection order)
            clearInstruction();
            // Use the exact same center position as deck starting position
            // Cards are positioned using percentage-based left/top, not pixels
            const cardSpacing = 180; // Spacing in pixels between cards

            // Calculate center using container's actual width for proper centering
            const containerRect = container.getBoundingClientRect();
            const containerCenterX = containerRect.width / 2;

            // Use selection order: 1st pick, 2nd pick, 3rd pick
            for (let i = 0; i < selectedCards.length; i++) {
                const selectedCard = selectedCards[i];
                let leftPosition;

                if (selectedCards.length === 1) {
                    // Single card: exact center (50%)
                    leftPosition = '50%';
                } else if (selectedCards.length === 3) {
                    // For 3 cards based on pick order:
                    // Calculate pixel positions, then convert back
                    let xOffset;
                    if (i === 0) xOffset = -cardSpacing;      // 1st pick â†’ Left
                    else if (i === 1) xOffset = 0;            // 2nd pick â†’ Center (50%)
                    else if (i === 2) xOffset = cardSpacing;  // 3rd pick â†’ Right

                    leftPosition = `${containerCenterX + xOffset}px`;
                } else {
                    // For multiple cards: spread evenly
                    const xOffset = (i - (selectedCards.length - 1) / 2) * cardSpacing;
                    leftPosition = `${containerCenterX + xOffset}px`;
                }

                selectedCard.element.style.left = leftPosition;
                selectedCard.element.style.top = '50%'; // Same as deck starting position
                selectedCard.element.style.transform = 'translate(-50%, -50%) scale(1.3)';
                selectedCard.element.style.boxShadow = '0 0 50px rgba(255, 215, 0, 1)';
                selectedCard.element.style.zIndex = 1000 + i;

                // Flip the card now (during move to center)
                if (selectedCard.reversed) {
                    selectedCard.element.classList.add('reversed');
                } else {
                    selectedCard.element.classList.add('flipped');
                }

                await sleep(300);
            }

            await sleep(800);

            // Phase 3: Display selected cards in the grid
            selectedGrid.innerHTML = '';
            selectedCards.forEach((selectedCard, index) => {
                const cardItem = document.createElement('div');
                cardItem.className = `selected-card-item ${selectedCard.reversed ? 'reversed' : ''}`;

                const imagePath = riderWaiteData.getImagePath(selectedCard.card);
                const orientationText = selectedCard.reversed ? '(Reversed)' : '(Upright)';

                cardItem.innerHTML = `
                    <img src="../${imagePath}" alt="${selectedCard.card.name}">
                    <h3>${selectedCard.card.name}</h3>
                    <p>${orientationText}</p>
                `;

                selectedGrid.appendChild(cardItem);
            });

            // Fade out center cards and show final reading
            await sleep(500);
            selectedCards.forEach(sc => {
                sc.element.style.opacity = '0';
                sc.element.style.transform = 'translate(-50%, -50%) scale(0)';
            });

            await sleep(500);

            selectedDisplay.classList.add('show');
            isAnimating = false;
        }

        function resetReading() {
            // Hide selected display
            selectedDisplay.classList.remove('show');

            // Clear container
            container.innerHTML = '';
            cards = [];
            selectedCards = [];

            // Re-enable button
            shuffleBtn.disabled = false;
            clearInstruction();
        }

        // Event listeners
        shuffleBtn.addEventListener('click', shuffleAnimation);

        cardCountSelect.addEventListener('change', () => {
            if (!isAnimating) {
                createDeck();
            }
        });

        // Initialize
        window.onload = function() {
            loadTarotDeck();
            createDeck();
            console.log('Animated Card Picker ready. Click "Shuffle Cards" to begin.');
        };
    </script>
</body>
</html>
